{"title":"浅谈JS运行机制，宏任务，微任务","uid":"b4572855b594ba24ba1854f956bab41e","slug":"javascript/jsyxjz","date":"2021-09-26T12:30:40.082Z","updated":"2021-09-22T07:06:56.893Z","comments":true,"path":"api/articles/javascript/jsyxjz.json","keywords":null,"cover":null,"content":"<h1 id=\"JS-单线程\"><a href=\"#JS-单线程\" class=\"headerlink\" title=\"JS 单线程\"></a>JS 单线程</h1><p>先聊聊JS的单线程工作，单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p>\n<p>那怎么样解决这种问题呢，在浏览器平台下，浏览器底层开启了多线程去执行了一些任务，形成了我们常说的异步任务，比如说定时器<code>setTimeout</code>，异步任务可以很好的解决代码阻塞问题，但这也会带来代码的执行顺序没有像同步任务那样直观明了，这也是我们本文的重点。</p>\n<h1 id=\"JS-运行机制\"><a href=\"#JS-运行机制\" class=\"headerlink\" title=\"JS 运行机制\"></a>JS 运行机制</h1><p>一开始整个脚本作为一个宏任务执行。执行过程中同步代码直接执行，宏任务等待时间到达或者成功后，将方法的回调放入宏任务队列中，微任务进入微任务队列。</p>\n<p>当前主线程的宏任务执行完出队，检查并清空微任务队列。接着执行浏览器 UI 线程的渲染工作，检查web worker 任务，有则执行。</p>\n<p>然后再取出一个宏任务执行。以此循环…</p>\n<p><strong>EventLoop</strong> 是一种循环机制 ，不断去轮询一些队列 ，从中找到需要执行的任务并按顺序执行的一个执行模型。</p>\n<h1 id=\"宏任务与微任务\"><a href=\"#宏任务与微任务\" class=\"headerlink\" title=\"宏任务与微任务\"></a>宏任务与微任务</h1><p><strong>宏任务</strong>可以理解为每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</p>\n<p>浏览器为了让 JS 内部宏任务 与 DOM 操作能够有序的执行，会在一个宏任务执行结束后，在下一个宏任务执行开始前，对页面进行重新渲染。</p>\n<p>宏任务包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、MessageChannel 等。</p>\n<p> <strong>微任务</strong>可以理解是在当前任务执行结束后需要立即执行的任务。也就是说，在当前任务后，在渲染之前，执行清空微任务。</p>\n<p>  所以它的响应速度相比宏任务会更快，因为无需等待 UI 渲染。</p>\n<p>  微任务包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)等。</p>\n<h1 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h1><pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">console.log(&#39;start&#39;)\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;s1&#39;)\n  Promise.resolve().then(() &#x3D;&gt; &#123;\n    console.log(&#39;p2&#39;)\n  &#125;)\n  Promise.resolve().then(() &#x3D;&gt; &#123;\n    console.log(&#39;p3&#39;)\n  &#125;)\n&#125;)\n\nPromise.resolve().then(() &#x3D;&gt; &#123;\n  console.log(&#39;p1&#39;)\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;s2&#39;)\n  &#125;)\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;s3&#39;)\n  &#125;)\n&#125;)\nconsole.log(&#39;end&#39;)\n</code></pre>\n\n<h2 id=\"代码分析EventLoop\"><a href=\"#代码分析EventLoop\" class=\"headerlink\" title=\"代码分析EventLoop\"></a>代码分析<strong>EventLoop</strong></h2><ol>\n<li>首先遇到 <code>console.log(&#39;start&#39;)</code> ，输出 <code>start</code>，继续执行。</li>\n<li>遇到 <code>setTimeout</code>，由于 <code>setTimeout</code> 是宏任务，时间到了将其放入宏任务队列中，继续执行。</li>\n<li>遇到 <code>Promise.then</code> ，由于当前是微任务，将其放入微任务队列中，继续执行。</li>\n<li>遇到 <code>console.log(&#39;end&#39;)</code> ，输出 <code>end</code>。</li>\n<li>此时，当前主线程中的任务已全部执行完毕， <code>EventLoop</code> 就开始工作，找需要执行的任务压入到执行栈中，微任务优先于宏任务，因此先把 <code>Promise.resolve().then</code> 压入到执行栈开始继续执行。</li>\n<li>遇到 <code>console.log(&#39;p1&#39;)</code> ，输出 <code>p1</code> ，继续执行。</li>\n<li>遇到两个 <code>setTimeout</code>  <code>s2</code>，<code>s3</code>， 放入到宏任务队列中等待执行。</li>\n<li>此时，当前主线程中的任务又全部执行完毕，检查并清空微任务队列，由于此时没有微任务，然后就取出之前第2步骤的宏任务 <code>setTimeout</code> 开始执行。</li>\n<li>输出 <code>s1</code> ，紧接着又遇到 <code>p2</code> ， <code>p3</code>两个微任务，将其放入微任务队列中。</li>\n<li>此时，当前主线程中的任务又全部执行完毕，检查并清空微任务队列。所以相继输出 <code>p2</code> ， <code>p3</code>。</li>\n<li>此时，当前主线程中的任务又全部执行完毕，检查并清空微任务队列，由于此时没有微任务，然后就取出之前第7步骤的宏任务 <code>setTimeout</code> 开始执行。所以相继输出 <code>s2</code> ， <code>s3</code>。</li>\n<li>整个js代码已全部完毕，最终输出顺序 <code>start</code>， <code>end</code>， <code>p1</code>，<code>s1</code>，<code>p2</code> ，<code>p3</code>， <code>s2</code>， <code>s3</code>。</li>\n</ol>\n","feature":true,"text":"JS 单线程先聊聊JS的单线程工作，单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 那怎么样解决这种问题呢，在浏览器平台下，浏览器底层开启了多线程去执行了一些任务，形成了我们常说的异步任务，比如说定时器s...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"web","slug":"web","count":5,"path":"api/categories/web.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":3,"path":"api/tags/JavaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JS-%E5%8D%95%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">JS 单线程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JS-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">JS 运行机制</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">宏任务与微任务</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">代码示例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90EventLoop\"><span class=\"toc-text\">代码分析EventLoop</span></a></li></ol></li></ol>","author":{"name":"黄振威","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3597257778138808","customs":{}}},"mapped":true,"prev_post":{"title":"Promise原理分析、手写Promise简易版","uid":"aebc5a3f3b331af7862288aae1caccd0","slug":"javascript/promise","date":"2021-09-26T12:30:40.085Z","updated":"2021-09-22T07:07:04.285Z","comments":true,"path":"api/articles/javascript/promise.json","keywords":null,"cover":null,"text":"一、前言Promise灵魂三问：是什么？做什么？怎么做？ 是什么？—-Promise 是异步编程的一种解决方案，ES6新增的一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。 做什么？—-P...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"web","slug":"web","count":5,"path":"api/categories/web.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":3,"path":"api/tags/JavaScript.json"}],"author":{"name":"黄振威","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3597257778138808","customs":{}}},"feature":true},"next_post":{"title":"闭包的概念及应用场景","uid":"00e349f9550fff228219dd858f639da6","slug":"javascript/bibao","date":"2021-09-26T12:30:40.078Z","updated":"2021-09-22T07:06:46.243Z","comments":true,"path":"api/articles/javascript/bibao.json","keywords":null,"cover":null,"text":"闭包的概念一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"web","slug":"web","count":5,"path":"api/categories/web.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":3,"path":"api/tags/JavaScript.json"}],"author":{"name":"黄振威","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3597257778138808","customs":{}}}}}