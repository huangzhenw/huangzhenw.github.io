{"title":"Promise原理分析、手写Promise简易版","uid":"aebc5a3f3b331af7862288aae1caccd0","slug":"javascript/promise","date":"2021-09-26T12:30:40.085Z","updated":"2021-09-22T07:07:04.285Z","comments":true,"path":"api/articles/javascript/promise.json","keywords":null,"cover":null,"content":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p><code>Promise</code>灵魂三问：是什么？做什么？怎么做？<br></p>\n<ol>\n<li>是什么？—-<code>Promise</code> 是异步编程的一种解决方案，ES6新增的一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。</li>\n<li>做什么？—-<code>Promise</code> 解决回调地狱的问题，在多层嵌套的回调方法中，如果同时存在同步、异步的方法，那么实际执行顺序会混乱，不好调试不好维护。</li>\n<li>怎么做？<br><br> 3.1 假设有一个需求，对接服务端接口时，想要拿到接口url 为 ‘url5’ 返回的data5，但是url5需要根据url4返回的数据作为参数，url4又需要url3返回的数据作为参数，以此类推 ······(嵌套层级略微夸张了一点点，但实际开发中经常出现类似这种依赖上一个接口返回的数据作为下一个接口的传递参数）<br><br><pre><code> 不使用`Promise`处理方案：\n</code></pre>\n <pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">$.get(&#39;&#x2F;url1&#39;, function (data1) &#123;\n  $.get(&#39;&#x2F;url2&#39;, data1, function (data2) &#123;\n    $.get(&#39;&#x2F;url3&#39;, data2, function (data3) &#123;\n      $.get(&#39;&#x2F;url4&#39;, data3, function (data4) &#123;\n        $.get(&#39;&#x2F;url5&#39;, data4, function (data5) &#123;\n            console.log(data5) \n          &#125;)\n      &#125;)\n    &#125;)\n  &#125;)\n&#125;)</code></pre>\n使用<code>Promise</code>处理方案： <pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  $.get(&#39;&#x2F;url1&#39;, data1 &#x3D;&gt; &#123;\n    resolve(data1)\n  &#125;)\n&#125;)\n   \npromise.then((data1) &#x3D;&gt; &#123;\n  $.get(&#39;&#x2F;url2&#39;, data1, data2 &#x3D;&gt; &#123;\n    return data2\n  &#125;)\n&#125;).then((data2) &#x3D;&gt; &#123;\n  $.get(&#39;&#x2F;url3&#39;, data2, data3 &#x3D;&gt; &#123;\n    return data3\n  &#125;)\n&#125;).then((data3) &#x3D;&gt; &#123;\n  $.get(&#39;&#x2F;url4&#39;, data3, data4 &#x3D;&gt; &#123;\n    console.log(data4)\n  &#125;)\n&#125;)\n</code></pre>\n<h1 id=\"二、Promise使用原理分析\"><a href=\"#二、Promise使用原理分析\" class=\"headerlink\" title=\"二、Promise使用原理分析\"></a>二、Promise使用原理分析</h1></li>\n<li><code>Promise</code> 就是一个类，在执行这个类的时候，需要传递一个执行器进去，执行器会立即执行<br></li>\n<li><code>Promise</code> 中有三种状态，分别为 等待<code>pending</code>， 成功 <code>fulfilled</code> ，失败 <code>rejected</code><br><br> <code>pending</code> -&gt; <code>fulfilled</code><br><br> <code>pending</code> -&gt; <code>rejected</code><br><br> 状态一旦确定就不可更改<br></li>\n<li><code>resolve</code>和<code>reject</code>函数是用来更改状态的<br><br> <code>resolve</code>：<code>fulfilled</code><br><br> <code>reject</code>：<code>rejected</code><br></li>\n<li><code>then</code>方法内部做的事情就判断状态 如果状态是成功就调用成功的回调函数 如果状态是失败，就调用失败的回调函数<br><br> <code>then</code>方法是定义在原型对象当中</li>\n<li><code>then</code>成功回调有一个参数 表示成功之后的值 <code>then</code>失败回调用一个参数，表示失败后的原因</li>\n</ol>\n<h1 id=\"三、手写Pormise\"><a href=\"#三、手写Pormise\" class=\"headerlink\" title=\"三、手写Pormise\"></a>三、手写Pormise</h1><ol>\n<li>创建<code>Mypromise.js</code>文件，根据上述1. 2. 3. 原理分析，我们定义三种状态，创建一个<code>MyPromise</code>的类，执行器立即执行，初始化状态为<code>PENDING</code>，定义<code>resolve</code>，<code>reject</code> 方法，代码如下：</li>\n</ol>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">const PENDING &#x3D; &quot;pending&quot; &#x2F;&#x2F;等待\nconst FULFILLED &#x3D; &quot;fulfilled&quot; &#x2F;&#x2F;成功\nconst REJECT &#x3D; &quot;reject&quot; &#x2F;&#x2F;失败\n\nclass MyPromise &#123;\n  constructor(executor) &#123;\n    executor(this.resolve, this.reject)\n  &#125;\n  &#x2F;&#x2F; 初始状态  等待\n  status &#x3D; PENDING\n\n  resolve &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果状态不是等待 阻止程序向下执行\n    if (this.status !&#x3D;&#x3D; PENDING) return\n    &#x2F;&#x2F; 将状态更改为成功\n    this.status &#x3D; FULFILLED\n  &#125;\n  reject &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果状态不是等待 阻止程序向下执行\n    if (this.status !&#x3D;&#x3D; PENDING) return\n    &#x2F;&#x2F; 将状态更改为失败\n    this.status &#x3D; REJECT\n  &#125;\n&#125;</code></pre>\n<ol start=\"2\">\n<li>根据上诉4. 5.原理分析，我们需要定义<code>then</code>方法，主要是判断当前状态调用成功或者失败的函数，需要提前声明<code>successCallback</code>和<code>failCallback</code>分别为成功和失败的回调函数，回调函数中需要传递成功的值<code>value</code>或者传递错误信息<code>reason</code>，因此<code>value</code>和<code>reason</code>需要提前声明，代码如下：</li>\n</ol>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;&#x2F; 声明成功返回的初始值\nvalue &#x3D; undefined\n&#x2F;&#x2F; 声明失败返回的原因\nreason &#x3D; undefined\n&#x2F;&#x2F; 声明成功回调函数\nsuccessCallback &#x3D; undefined\n&#x2F;&#x2F; 声明失败回调函数\nfailCallback &#x3D; undefined\nthen (successCallback, failCallback) &#123;\n    if (this.status &#x3D;&#x3D;&#x3D; FULFILLED) &#123;\n      successCallback(this.value)\n    &#125; else if (this.status &#x3D;&#x3D;&#x3D; REJECT) &#123;\n      failCallback(this.reason)\n    &#125;\n&#125;</code></pre>\n<p>因为我们<code>then</code>方法中<code>successCallback</code>和<code>failCallback</code>回调函数中需要用上<code>value</code>和<code>reason</code>的值作为参数传递，所以我们应该在<code>resolve</code>和<code>reject</code>中分别保存接受到的<code>value</code>和<code>reason</code>，代码修改如下：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">resolve &#x3D; value &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果状态不是等待 阻止程序向下执行\n    if (this.status !&#x3D;&#x3D; PENDING) return\n    &#x2F;&#x2F; 将状态更改为成功\n    this.status &#x3D; FULFILLED\n    &#x2F;&#x2F; 保存成功之后的值，传递给then方法\n    this.value &#x3D; value\n    &#125;\n    reject &#x3D; reason &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果状态不是等待 阻止程序向下执行\n    if (this.status !&#x3D;&#x3D; PENDING) return\n    &#x2F;&#x2F; 将状态更改为失败\n    this.status &#x3D; REJECT\n    &#x2F;&#x2F; 保存失败之后的原因，传递给then方法\n    this.reason &#x3D; reason\n&#125;</code></pre>\n<p>此时，基础简易版已经完成，需要<code>module.exports = MyPromise</code>导出</p>\n<h1 id=\"四、最终代码和使用\"><a href=\"#四、最终代码和使用\" class=\"headerlink\" title=\"四、最终代码和使用\"></a>四、最终代码和使用</h1><p><code>MyPromise.js</code></p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">const PENDING &#x3D; &quot;pending&quot; &#x2F;&#x2F;等待\nconst FULFILLED &#x3D; &quot;fulfilled&quot; &#x2F;&#x2F;成功\nconst REJECT &#x3D; &quot;reject&quot; &#x2F;&#x2F;失败\n\nclass MyPromise &#123;\n  constructor(executor) &#123;\n    executor(this.resolve, this.reject)\n  &#125;\n  &#x2F;&#x2F; 初始状态  等待\n  status &#x3D; PENDING\n  &#x2F;&#x2F; 声明成功返回的初始值\n  value &#x3D; undefined\n  &#x2F;&#x2F; 声明失败返回的原因\n  reason &#x3D; undefined\n  &#x2F;&#x2F; 声明成功回调函数\n  successCallback &#x3D; undefined\n  &#x2F;&#x2F; 声明失败回调函数\n  failCallback &#x3D; undefined\n  resolve &#x3D; value &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果状态不是等待 阻止程序向下执行\n    if (this.status !&#x3D;&#x3D; PENDING) return\n    &#x2F;&#x2F; 将状态更改为成功\n    this.status &#x3D; FULFILLED\n    &#x2F;&#x2F; 保存成功之后的值，传递给then方法\n    this.value &#x3D; value\n  &#125;\n  reject &#x3D; reason &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果状态不是等待 阻止程序向下执行\n    if (this.status !&#x3D;&#x3D; PENDING) return\n    &#x2F;&#x2F; 将状态更改为失败\n    this.status &#x3D; REJECT\n    &#x2F;&#x2F; 保存失败之后的原因，传递给then方法\n    this.reason &#x3D; reason\n  &#125;\n  then (successCallback, failCallback) &#123;\n    if (this.status &#x3D;&#x3D;&#x3D; FULFILLED) &#123;\n      successCallback(this.value)\n    &#125; else if (this.status &#x3D;&#x3D;&#x3D; REJECT) &#123;\n      failCallback(this.reason)\n    &#125;\n  &#125;\n&#125;\n\nmodule.exports &#x3D; MyPromise</code></pre>\n<p>创建<code>index.js</code>导入我们的<code>Pormise</code>类并使用它，代码如下：</p>\n<pre class=\"line-numbers language-j\" data-language=\"j\"><code class=\"language-j\">const MyPromise &#x3D; require(&#39;.&#x2F;MyPromise&#39;)\n\nlet promise &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;\n  resolve(&#39;成功值&#39;)\n  &#x2F;&#x2F; reject(&#39;失败信息&#39;)\n&#125;)\npromise.then(value &#x3D;&gt; &#123;\n  console.log(value) &#x2F;&#x2F; 成功值\n&#125;, reason &#x3D;&gt; &#123;\n  console.log(reason) &#x2F;&#x2F; 失败信息\n&#125;)</code></pre>\n\n<p>在控制台中输入<code>node index.js</code>启动</p>\n","feature":true,"text":"一、前言Promise灵魂三问：是什么？做什么？怎么做？ 是什么？—-Promise 是异步编程的一种解决方案，ES6新增的一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。 做什么？—-P...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"web","slug":"web","count":5,"path":"api/categories/web.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":3,"path":"api/tags/JavaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">一、前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81Promise%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90\"><span class=\"toc-text\">二、Promise使用原理分析</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E6%89%8B%E5%86%99Pormise\"><span class=\"toc-text\">三、手写Pormise</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81%E5%92%8C%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">四、最终代码和使用</span></a></li></ol>","author":{"name":"黄振威","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3597257778138808","customs":{}}},"mapped":true,"prev_post":{"title":"深入分析前端性能优化及优化方案","uid":"6e40165d20a98baca2bd23d54541bc50","slug":"performance/performance","date":"2021-09-26T12:30:40.101Z","updated":"2021-09-22T02:02:08.052Z","comments":true,"path":"api/articles/performance/performance.json","keywords":null,"cover":[],"text":"你是否经历过以下场景： 面试中 谈谈你对性能优化的理解 输入URL整个页面经历了什么过程？ … 工作中 页面加载好慢，不知道是前端问题还是后端问题 页面交互卡顿，不知道具体哪里出了问题 … 如果有遇到此类型问题，希望我近期对性能优化的知识沉淀能够帮助到你，这篇文章先分析渲染过程，...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"22 mins."},"categories":[{"name":"web","slug":"web","count":5,"path":"api/categories/web.json"}],"tags":[{"name":"前端性能优化","slug":"前端性能优化","count":1,"path":"api/tags/前端性能优化.json"}],"author":{"name":"黄振威","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3597257778138808","customs":{}}},"feature":true},"next_post":{"title":"浅谈JS运行机制，宏任务，微任务","uid":"b4572855b594ba24ba1854f956bab41e","slug":"javascript/jsyxjz","date":"2021-09-26T12:30:40.082Z","updated":"2021-09-22T07:06:56.893Z","comments":true,"path":"api/articles/javascript/jsyxjz.json","keywords":null,"cover":null,"text":"JS 单线程先聊聊JS的单线程工作，单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 那怎么样解决这种问题呢，在浏览器平台下，浏览器底层开启了多线程去执行了一些任务，形成了我们常说的异步任务，比如说定时器s...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"web","slug":"web","count":5,"path":"api/categories/web.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":3,"path":"api/tags/JavaScript.json"}],"author":{"name":"黄振威","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3597257778138808","customs":{}}},"feature":true}}