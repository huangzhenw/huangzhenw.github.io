{"title":"闭包的概念及应用场景","uid":"00e349f9550fff228219dd858f639da6","slug":"javascript/bibao","date":"2021-09-26T12:30:40.078Z","updated":"2021-09-22T07:06:46.243Z","comments":true,"path":"api/articles/javascript/bibao.json","keywords":null,"cover":null,"content":"<h1 id=\"闭包的概念\"><a href=\"#闭包的概念\" class=\"headerlink\" title=\"闭包的概念\"></a>闭包的概念</h1><p>一个函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。—摘自于MDN上对闭包的解释，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures\">前往MDN-闭包</a>。</p>\n<p>通俗点说就是：只要一个函数访问了一个不属于当前函数作用域的变量就称为闭包。</p>\n<p>下面看一个MDN上简单的例子：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function init() &#123;\n    var name &#x3D; &quot;Mozilla&quot;; &#x2F;&#x2F; name 是一个被 init 创建的局部变量\n    function displayName() &#123; &#x2F;&#x2F; displayName() 是内部函数，一个闭包\n        alert(name); &#x2F;&#x2F; 使用了父函数中声明的变量\n    &#125;\n    displayName();\n&#125;\ninit();</code></pre>\n\n<p><code>init()</code> 创建了一个局部变量 <code>name</code> 和一个名为 <code>displayName()</code> 的函数。<code>displayName()</code> 是定义在 <code>init()</code> 里的内部函数，并且仅在 <code>init()</code> 函数体内可用。请注意，<code>displayName()</code> 没有自己的局部变量。然而，因为它可以访问到外部函数的变量，所以 <code>displayName()</code> 可以使用父函数 <code>init()</code> 中声明的变量 <code>name</code> 。</p>\n<p>从例子上可以看出，其实就是一种作用域链，在<code>displayName</code>内部函数中，访问<code>name</code>属性，但在其内部作用域中没有找到<code>name</code>属性，因此往作用域链上找，也就是在<code>init</code>函数里面找到了<code>name</code>属性。</p>\n<h1 id=\"有意义的闭包\"><a href=\"#有意义的闭包\" class=\"headerlink\" title=\"有意义的闭包\"></a>有意义的闭包</h1><p>根据上面例子改造：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function init() &#123;\n  var name &#x3D; &quot;Mozilla&quot;\n  return function displayName() &#123;\n    console.log(name)\n  &#125;\n&#125;\nlet fn &#x3D; init()\nfn()</code></pre>\n\n<p>此案例中，在<code>init</code>函数中，返回<code>displayName</code>函数，且在<code>displayName</code>函数内引用了外部函数<code>init</code>的中变量<code>name</code>，此时就形成了一个闭包。</p>\n<h1 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h1><h2 id=\"柯里化函数\"><a href=\"#柯里化函数\" class=\"headerlink\" title=\"柯里化函数\"></a>柯里化函数</h2><p>柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;&#x2F; 假设我们有一个求长方形面积的函数\nfunction getArea(width, height) &#123;\n    return width * height\n&#125;\n&#x2F;&#x2F; 柯里化之前\n&#x2F;&#x2F; 如果我们碰到的长方形的宽老是10\nconst area1 &#x3D; getArea(10, 20)\nconst area2 &#x3D; getArea(10, 30)\nconst area3 &#x3D; getArea(10, 40)\n\n&#x2F;&#x2F; 我们可以使用闭包柯里化这个计算面积的函数\nfunction getArea(width) &#123;\n    return height &#x3D;&gt; &#123;\n        return width * height\n    &#125;\n&#125;\n\nconst getTenWidthArea &#x3D; getArea(10)\n&#x2F;&#x2F; 之后碰到宽度为10的长方形就可以这样计算面积\nconst area1 &#x3D; getTenWidthArea(20)\n\n&#x2F;&#x2F; 而且如果遇到宽度偶尔变化也可以轻松复用\nconst getTwentyWidthArea &#x3D; getArea(20)</code></pre>\n\n\n<h1 id=\"闭包总结\"><a href=\"#闭包总结\" class=\"headerlink\" title=\"闭包总结\"></a>闭包总结</h1><ul>\n<li>  <strong>形成：</strong>  函数中嵌套函数，且内部函数引用外部函数的变量</li>\n<li>  <strong>作用：</strong>  延长变量生命周期</li>\n<li>  <strong>优点：</strong>  希望一个变量长期存在内存中、模块化代码避免全局变量的污染、私有属性</li>\n<li>  <strong>缺点：</strong>  无法回收闭包中引用变量，容易造成内存泄漏</li>\n</ul>\n","text":"闭包的概念一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"web","slug":"web","count":5,"path":"api/categories/web.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":3,"path":"api/tags/JavaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">闭包的概念</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">有意义的闭包</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">柯里化函数</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">闭包总结</span></a></li></ol>","author":{"name":"黄振威","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3597257778138808","customs":{}}},"mapped":true,"prev_post":{"title":"浅谈JS运行机制，宏任务，微任务","uid":"b4572855b594ba24ba1854f956bab41e","slug":"javascript/jsyxjz","date":"2021-09-26T12:30:40.082Z","updated":"2021-09-22T07:06:56.893Z","comments":true,"path":"api/articles/javascript/jsyxjz.json","keywords":null,"cover":null,"text":"JS 单线程先聊聊JS的单线程工作，单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 那怎么样解决这种问题呢，在浏览器平台下，浏览器底层开启了多线程去执行了一些任务，形成了我们常说的异步任务，比如说定时器s...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"web","slug":"web","count":5,"path":"api/categories/web.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":3,"path":"api/tags/JavaScript.json"}],"author":{"name":"黄振威","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3597257778138808","customs":{}}},"feature":true},"next_post":{}}