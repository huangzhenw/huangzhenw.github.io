{"title":"ES6新特性总结","uid":"0bf9a689624da39bf1a0f3472d46351e","slug":"es/es6","date":"2021-09-26T12:30:40.064Z","updated":"2021-09-26T12:35:44.176Z","comments":true,"path":"api/articles/es/es6.json","keywords":null,"cover":null,"content":"<h2 id=\"ES6新特性总结\"><a href=\"#ES6新特性总结\" class=\"headerlink\" title=\"ES6新特性总结\"></a>ES6新特性总结</h2><p>ps: 借鉴阮一峰老师的ECMAScript 6 入门；<a href=\"https://es6.ruanyifeng.com/?search=assign&x=0&y=0\">传送门</a>，MDN文档；<a href=\"https://developer.mozilla.org/zh-CN/\">传送门</a></p>\n<h3 id=\"let、const、var关键字\"><a href=\"#let、const、var关键字\" class=\"headerlink\" title=\"let、const、var关键字\"></a>let、const、var关键字</h3><h4 id=\"三个关键字的比较：\"><a href=\"#三个关键字的比较：\" class=\"headerlink\" title=\"三个关键字的比较：\"></a>三个关键字的比较：</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>var</th>\n<th>let</th>\n<th>Const</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>变量提升</td>\n<td>√</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>全局变量</td>\n<td>√</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>重复声明</td>\n<td>√</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>重新赋值</td>\n<td>√</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr>\n<td>只声明不初始化</td>\n<td>√</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr>\n<td>暂时死区</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>块作用域</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n</tbody></table>\n<h4 id=\"什么是暂时性死区？\"><a href=\"#什么是暂时性死区？\" class=\"headerlink\" title=\"什么是暂时性死区？\"></a>什么是暂时性死区？</h4><p>let 和 const 声明的变量不存在变量提升，其作用域都是块级作用域，凡是在声明变量之前使用变量就会报错，所以，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）</p>\n<h4 id=\"const关键字你不知道的事：\"><a href=\"#const关键字你不知道的事：\" class=\"headerlink\" title=\"const关键字你不知道的事：\"></a>const关键字你不知道的事：</h4><p>1、对象属性修改和数组元素变化不会触发 const 错误</p>\n<p>原因： const 实际上是将 const 变量存储的那个指针固定，因此如果声明的是引用数据类型，只是不能修改指针，但是可以修改指针指向的内存数据</p>\n<p>2、声明对象类型优先使用  const ，非对象类型声明优先选择 let</p>\n<h3 id=\"变量的解构赋值\"><a href=\"#变量的解构赋值\" class=\"headerlink\" title=\"变量的解构赋值\"></a>变量的解构赋值</h3><h4 id=\"数组的解构\"><a href=\"#数组的解构\" class=\"headerlink\" title=\"数组的解构\"></a>数组的解构</h4><p>ES5中，为了从数组中获取特定数据并赋值给变量，我们经常会进行如下的操作：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [100, 200, 300]\nconst a &#x3D; arr[0]\nconst b &#x3D; arr[1]\nconst c &#x3D; arr[2]\nconsole.log(a) &#x2F;&#x2F; 100\nconsole.log(b) &#x2F;&#x2F; 200\nconsole.log(c) &#x2F;&#x2F; 300</code></pre>\n\n<p>ES6为数组添加了解构功能，以简化获取数组中数据的过程。数组解构采用数组字面量的语法形式，即等号左边的变量通过在数组中的位置去取得等号右边的数组字面量相同位置的值。</p>\n<p><strong>例子：</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [100, 200, 300]\nconst [a, b, c] &#x3D; arr\nconsole.log(a) &#x2F;&#x2F; 100\nconsole.log(b) &#x2F;&#x2F; 200\nconsole.log(c) &#x2F;&#x2F; 300</code></pre>\n\n<p>如果只需要拿到数组指定位置的元素</p>\n<p><strong>例子：</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [100, 200, 300]\nconst [a] &#x3D; arr\nconsole.log(a) &#x2F;&#x2F; 100\nconst [, b] &#x3D; arr\nconsole.log(b) &#x2F;&#x2F; 200\nconst [, , c] &#x3D; arr\nconsole.log(c) &#x2F;&#x2F; 300</code></pre>\n\n\n\n<p>其中，我们还可以使用扩展运算符的方式（…）结构出从当前位置到最后位置从而合并成一个新数组</p>\n<p><strong>例子：</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [100, 200, 300]\nconst [a, ...arr1] &#x3D; arr\nconsole.log(a) &#x2F;&#x2F; 100\nconsole.log(arr1) &#x2F;&#x2F; [200, 300]</code></pre>\n\n\n\n<p>当解构左边比实际数组的长度还多的时候，多余的变量默认值为<code>undefind</code></p>\n<p><strong>例子：</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [100, 200, 300]\nconst [a, b, c, d] &#x3D; arr\nconsole.log(d) &#x2F;&#x2F; undefind\n&#x2F;&#x2F; 我们可以给d设置默认值\nconst [a, b, c, d &#x3D; 400] &#x3D; arr\nconsole.log(d) &#x2F;&#x2F; 400</code></pre>\n\n\n\n<h4 id=\"对象的解构\"><a href=\"#对象的解构\" class=\"headerlink\" title=\"对象的解构\"></a>对象的解构</h4><p>对象的解构和数组解构不同的是，数组解构是根据数组的下标顺序，解构出相对应下标的元素，</p>\n<p>而对象是没有下标这种规律性的，需要根据对象中的属性名解构。</p>\n<p>其他特点和数组的解构都是相同的。</p>\n<p><strong>例子：</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123; name: &#39;weision&#39;, age: 18 &#125;\nconst &#123; name &#125; &#x3D; obj\nconsole.log(name) &#x2F;&#x2F; weision\n\n&#x2F;&#x2F; 利用这个特性，可以结构出console中的log方法，帮助我们在开发中写少量的代码\nconst &#123; log &#125; &#x3D; console\nlog(name) &#x2F;&#x2F; weision</code></pre>\n\n\n\n<h3 id=\"模版字符串\"><a href=\"#模版字符串\" class=\"headerlink\" title=\"模版字符串\"></a>模版字符串</h3><p>传统的  JavaScript  语言，输出模板通常是这样写的（下面使用了  jQuery  的方法）。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">$(&#39;#result&#39;).append(\n  &#39;There are &lt;b&gt;&#39; + basket.count + &#39;&lt;&#x2F;b&gt; &#39; +\n  &#39;items in your basket, &#39; +\n  &#39;&lt;em&gt;&#39; + basket.onSale +\n  &#39;&lt;&#x2F;em&gt; are on sale!&#39;\n);</code></pre>\n\n<p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">$(&#39;#result&#39;).append(&#96;\n  There are &lt;b&gt;$&#123;basket.count&#125;&lt;&#x2F;b&gt; items\n   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;&#x2F;em&gt;\n  are on sale!\n&#96;);</code></pre>\n\n<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;&#x2F; 普通字符串\n&#96;In JavaScript &#39;\\n&#39; is a line-feed.&#96;\n\n&#x2F;&#x2F; 多行字符串\n&#96;In JavaScript this is\n not legal.&#96;\n\nconsole.log(&#96;string text line 1\nstring text line 2&#96;);\n\n&#x2F;&#x2F; 字符串中嵌入变量\nlet name &#x3D; &quot;Bob&quot;, time &#x3D; &quot;today&quot;;\n&#96;Hello $&#123;name&#125;, how are you $&#123;time&#125;?&#96;</code></pre>\n\n\n\n<h3 id=\"字符串的扩展方法\"><a href=\"#字符串的扩展方法\" class=\"headerlink\" title=\"字符串的扩展方法\"></a>字符串的扩展方法</h3><p>这里介绍三个比较常用的查找字符串的方法</p>\n<p><code>includes()</code>，<code>startaWith()</code>，<code>endsWith()</code></p>\n<p>分别为</p>\n<ul>\n<li>是否包含某个字符串</li>\n<li>是否以某个字符串开头</li>\n<li>是否以某个字符串结尾</li>\n</ul>\n<p>他们返回的都是 <code>Boolean</code> 类型</p>\n<p><strong>例子：</strong></p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">const message &#x3D; &#39;Error: foo is not defind.&#39;\n\nconsole.log(message.includes(‘foo’)) &#x2F;&#x2F; true \nconsole.log(message.startaWith(‘Error’)) &#x2F;&#x2F; true \nconsole.log(message.endsWith(‘.’)) &#x2F;&#x2F; true </code></pre>\n\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>在 MDN 上的定义：<strong>箭头函数表达式</strong>的语法比<strong>函数表达式</strong>更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;&#x2F; 普通函数\nfunction inc (number) &#123;\n\treturn number + 1\n&#125;\nconsole.log(inc(1)) &#x2F;&#x2F; 2\n\n&#x2F;&#x2F; 箭头函数\nconst inc &#x3D; (n) &#x3D;&gt; &#123;\n    return n + 1\n&#125;\nconsole.log(inc(1)) &#x2F;&#x2F; 2\n\n&#x2F;&#x2F; 最简方式\nconst inc &#x3D; n &#x3D;&gt; n + 1\nconsole.log(inc(1)) &#x2F;&#x2F; 2</code></pre>\n\n<p>箭头函数不会改变 this 指向</p>\n<p><strong>例子：</strong></p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;&#x2F; 普通函数\nconst person &#x3D; &#123;\n  name: &#39;weision&#39;,\n  sayHi: function () &#123;\n    console.log(&#96;hi, my name is $&#123;this.name&#125;&#96;)\n  &#125;\n&#125;\nperson.sayHi() &#x2F;&#x2F; hi, my name is weision\n\n&#x2F;&#x2F; 箭头函数\nconst person &#x3D; &#123;\n  name: &#39;weision&#39;,\n  sayHi: () &#x3D;&gt; &#123;\n    console.log(&#96;hi, my name is $&#123;this.name&#125;&#96;)\n  &#125;\n&#125;\nperson.sayHi() &#x2F;&#x2F; hi, my name is undefined\n</code></pre>\n\n<h3 id=\"对象的新增方法\"><a href=\"#对象的新增方法\" class=\"headerlink\" title=\"对象的新增方法\"></a>对象的新增方法</h3><h4 id=\"1-Object-assign\"><a href=\"#1-Object-assign\" class=\"headerlink\" title=\"1. Object.assign()\"></a>1. Object.assign()</h4><p><strong>基础用法</strong></p>\n<p><code>Object.assign()</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const target &#x3D; &#123; a: 1 &#125;;\n\nconst source1 &#x3D; &#123; b: 2 &#125;;\nconst source2 &#x3D; &#123; c: 3 &#125;;\n\nObject.assign(target, source1, source2);\ntarget &#x2F;&#x2F; &#123;a:1, b:2, c:3&#125;</code></pre>\n\n<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const target &#x3D; &#123; a: 1, b: 1 &#125;;\n\nconst source1 &#x3D; &#123; b: 2, c: 2 &#125;;\nconst source2 &#x3D; &#123; c: 3 &#125;;\n\nObject.assign(target, source1, source2);\ntarget &#x2F;&#x2F; &#123;a:1, b:2, c:3&#125;</code></pre>\n\n<p>如果只有一个参数，<code>Object.assign()</code>会直接返回该参数。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;a: 1&#125;;\nObject.assign(obj) &#x3D;&#x3D;&#x3D; obj &#x2F;&#x2F; true</code></pre>\n\n<p>如果该参数不是对象，则会先转成对象，然后返回。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">typeof Object.assign(2) &#x2F;&#x2F; &quot;object&quot;</code></pre>\n\n<p><strong>注意点</strong></p>\n<p><strong>1.浅拷贝</strong></p>\n<p><code>Object.assign()</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj1 &#x3D; &#123;a: &#123;b: 1&#125;&#125;;\nconst obj2 &#x3D; Object.assign(&#123;&#125;, obj1);\n\nobj1.a.b &#x3D; 2;\nobj2.a.b &#x2F;&#x2F; 2</code></pre>\n\n<p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign()</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>\n<p><strong>2.数组的处理</strong></p>\n<p><code>Object.assign()</code>可以用来处理数组，但是会把数组视为对象。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Object.assign([1, 2, 3], [4, 5]) &#x2F;&#x2F; [4, 5, 3]</code></pre>\n\n<p>上面代码中，<code>Object.assign()</code>把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性<code>4</code>覆盖了目标数组的 0 号属性<code>1</code>。</p>\n<h4 id=\"2-Object-is\"><a href=\"#2-Object-is\" class=\"headerlink\" title=\"2.Object.is()\"></a>2.Object.is()</h4><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>\n<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Object.is(&#39;foo&#39;, &#39;foo&#39;) &#x2F;&#x2F; true\n\nObject.is(&#123;&#125;, &#123;&#125;) &#x2F;&#x2F; false</code></pre>\n\n<p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">+0 &#x3D;&#x3D;&#x3D; -0 &#x2F;&#x2F;true\nNaN &#x3D;&#x3D;&#x3D; NaN &#x2F;&#x2F; false\n\nObject.is(+0, -0) &#x2F;&#x2F; false\nObject.is(NaN, NaN) &#x2F;&#x2F; true</code></pre>\n\n\n\n<h3 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h3><p><strong>Proxy</strong> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const p &#x3D; new Proxy(target, handler)</code></pre>\n\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p><strong>target</strong></p>\n<p>要使用 <code>Proxy</code> 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p>\n<p><strong>handler</strong></p>\n<p>一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>p</code> 的行为。</p>\n<p><strong>handler</strong>两个重要的对象的方法</p>\n<ol>\n<li><p>handler.get() 用于拦截对象的读取属性操作。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var p &#x3D; new Proxy(target, &#123;\n  get: function(target, property, receiver) &#123;\n  &#125;\n&#125;);</code></pre></li>\n<li><p>handler.set() 用于设置属性值操作的捕获器。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const p &#x3D; new Proxy(target, &#123;\n  set: function(target, property, value, receiver) &#123;\n  &#125;\n&#125;);</code></pre></li>\n</ol>\n<p><strong>参数解读</strong></p>\n<p><strong>target</strong>： 目标对象。</p>\n<p><strong>property</strong>： 将被设置的属性名或 Symbol。</p>\n<p><strong>value</strong>： 新属性值。</p>\n<p><strong>receiver</strong>： 最初被调用的对象。通常是 proxy 本身，但 handler 的 set 方法也有可能在原型链上，或以其他方式被间接地调用（因此不一定是 proxy 本身）。</p>\n<p><strong>比如：</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">假设有一段代码执行 &#96;obj.name &#x3D; &quot;jen&quot;&#96;， &#96;obj&#96; 不是一个 proxy，且自身不含 &#96;name&#96; 属性，但是它的原型链上有一个 proxy，那么，那个 proxy 的 &#96;set()&#96; 处理器会被调用，而此时，&#96;obj&#96; 会作为 receiver 参数传进来。</code></pre>\n\n<p>​    </p>\n<h4 id=\"Proxy-对比-Object-defineProperty\"><a href=\"#Proxy-对比-Object-defineProperty\" class=\"headerlink\" title=\"Proxy 对比 Object.defineProperty()\"></a>Proxy 对比 Object.defineProperty()</h4><p><strong>优势1：Proxy 可以监视读写以外的操作</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const person &#x3D; &#123;\n  name: &#39;weision&#39;,\n  age: 18\n&#125;\n\nconst personProxy &#x3D; new Proxy(person, &#123;\n  deleteProperty (target, property) &#123;\n    console.log(&#39;delete&#39;, property)\n    delete target[property] \n  &#125;\n&#125;)\n\ndelete personProxy.age\nconsole.log(person)</code></pre>\n\n<p><strong>优势2：Proxy 可以很方便的监视数组操作</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const list &#x3D; []\n\nconst listProxy &#x3D; new Proxy(list, &#123;\n  set (target, property, value) &#123;\n    console.log(&#39;set&#39;, property, value)\n    target[property] &#x3D; value\n    return true &#x2F;&#x2F; 表示设置成功\n  &#125;\n&#125;)\n\nlistProxy.push(100)\nlistProxy.push(100)</code></pre>\n\n<p><strong>优势3：Proxy 不需要侵入对象</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const person &#x3D; &#123;&#125;\n\nObject.defineProperty(person, &#39;name&#39;, &#123;\n  get () &#123;\n    console.log(&#39;name 被访问&#39;)\n    return person._name\n  &#125;,\n  set (value) &#123;\n    console.log(&#39;name 被设置&#39;)\n    person._name &#x3D; value\n  &#125;\n&#125;)\nObject.defineProperty(person, &#39;age&#39;, &#123;\n  get () &#123;\n    console.log(&#39;age 被访问&#39;)\n    return person._age\n  &#125;,\n  set (value) &#123;\n    console.log(&#39;age 被设置&#39;)\n    person._age &#x3D; value\n  &#125;\n&#125;)\n\nperson.name &#x3D; &#39;jack&#39;\n\nconsole.log(person.name)\n\n&#x2F;&#x2F; Proxy 方式更为合理\nconst person2 &#x3D; &#123;\n  name: &#39;zce&#39;,\n  age: 20\n&#125;\n\nconst personProxy &#x3D; new Proxy(person2, &#123;\n  get (target, property) &#123;\n    console.log(&#39;get&#39;, property)\n    return target[property]\n  &#125;,\n  set (target, property, value) &#123;\n    console.log(&#39;set&#39;, property, value)\n    target[property] &#x3D; value\n  &#125;\n&#125;)\n\npersonProxy.name &#x3D; &#39;jack&#39;\n\nconsole.log(personProxy.name)\nconsole.log(personProxy.name)</code></pre>\n\n\n\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>ps: 借鉴MDN上<code>promise</code>概念描述，加上自己的语境和案例记录学习<code>promise</code>的成果，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\">MDN传送门</a>。</p>\n<h4 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h4><p>一个 <code>Promise</code> 对象代表一个在这个 promise 被创建出来时不一定已知的值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 <em>promise</em>，以便在未来某个时候把值交给使用者。</p>\n<p>一个 <code>Promise</code> 必然处于以下几种状态之一：</p>\n<ul>\n<li><em>待定（pending）</em>: 初始状态，既没有被兑现，也没有被拒绝。</li>\n<li><em>已兑现（fulfilled）</em>: 意味着操作成功完成。</li>\n<li><em>已拒绝（rejected）</em>: 意味着操作失败。</li>\n</ul>\n<p>待定状态的 Promise 对象要么会通过一个值<em>被兑现（fulfilled）</em>，要么会通过一个原因（错误）<em>被拒绝（rejected）</em>。当这些情况之一发生时，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。如果 promise 在一个相应的处理程序被绑定时就已经被兑现或被拒绝了，那么这个处理程序就会被调用，因此在完成异步操作和绑定处理方法之间不会存在竞争状态。</p>\n<h4 id=\"解决什么问题\"><a href=\"#解决什么问题\" class=\"headerlink\" title=\"解决什么问题\"></a>解决什么问题</h4><p>promise主要是用来解决以下问题的：</p>\n<ul>\n<li>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象</li>\n<li>promise可以支持多个并发的请求，获取并发请求中的数据</li>\n</ul>\n<p>\u000b</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 回调地狱，只是示例，不能运行\n\n$.get(&#39;&#x2F;url1&#39;, function (data1) &#123;\n  $.get(&#39;&#x2F;url2&#39;, data1, function (data2) &#123;\n    $.get(&#39;&#x2F;url3&#39;, data2, function (data3) &#123;\n      $.get(&#39;&#x2F;url4&#39;, data3, function (data4) &#123;\n        $.get(&#39;&#x2F;url5&#39;, data4, function (data5) &#123;\n          $.get(&#39;&#x2F;url6&#39;, data5, function (data6) &#123;\n            $.get(&#39;&#x2F;url7&#39;, data6, function (data7) &#123;\n              &#x2F;&#x2F; 略微夸张了一点点\n            &#125;)\n          &#125;)\n        &#125;)\n      &#125;)\n    &#125;)\n  &#125;)\n&#125;)</code></pre>\n\n<p>以上回调地狱代码示例，在远古时期（promise诞生前）经常遇到，这让开发者很难维护和读解代码。</p>\n<h4 id=\"Promise-基本示例\"><a href=\"#Promise-基本示例\" class=\"headerlink\" title=\"Promise 基本示例\"></a>Promise 基本示例</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const promise &#x3D; new Promise(function (resolve, reject) &#123;\n  &#x2F;&#x2F; 这里用于“兑现”承诺\n\n  &#x2F;&#x2F; resolve(100) &#x2F;&#x2F; 承诺达成\n\n  reject(new Error(&#39;promise rejected&#39;)) &#x2F;&#x2F; 承诺失败\n&#125;)\n\npromise.then(function (value) &#123;\n  &#x2F;&#x2F; 即便没有异步操作，then 方法中传入的回调仍然会被放入队列，等待下一轮执行\n  console.log(&#39;resolved&#39;, value)\n&#125;, function (error) &#123;\n  console.log(&#39;rejected&#39;, error)\n&#125;)\n\nconsole.log(&#39;end&#39;)</code></pre>\n\n<h4 id=\"Promise-方式的-AJAX\"><a href=\"#Promise-方式的-AJAX\" class=\"headerlink\" title=\"Promise 方式的 AJAX\"></a>Promise 方式的 AJAX</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function ajax (url) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    var xhr &#x3D; new XMLHttpRequest()\n    xhr.open(&#39;GET&#39;, url)\n    xhr.responseType &#x3D; &#39;json&#39;\n    xhr.onload &#x3D; function () &#123;\n      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        resolve(this.response)\n      &#125; else &#123;\n        reject(new Error(this.statusText))\n      &#125;\n    &#125;\n    xhr.send()\n  &#125;)\n&#125;\n\najax(&#39;&#x2F;api&#x2F;foo.json&#39;).then(function (res) &#123;\n  console.log(res)\n&#125;, function (error) &#123;\n  console.log(error)\n&#125;)\n</code></pre>\n\n\n\n<h4 id=\"Promise-常见误区\"><a href=\"#Promise-常见误区\" class=\"headerlink\" title=\"Promise 常见误区\"></a>Promise 常见误区</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function ajax (url) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    var xhr &#x3D; new XMLHttpRequest()\n    xhr.open(&#39;GET&#39;, url)\n    xhr.responseType &#x3D; &#39;json&#39;\n    xhr.onload &#x3D; function () &#123;\n      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        resolve(this.response)\n      &#125; else &#123;\n        reject(new Error(this.statusText))\n      &#125;\n    &#125;\n    xhr.send()\n  &#125;)\n&#125;\n\n&#x2F;&#x2F; 嵌套使用 Promise 是最常见的误区\n&#x2F;&#x2F; ajax(&#39;&#x2F;api&#x2F;urls.json&#39;).then(function (urls) &#123;\n&#x2F;&#x2F;   ajax(urls.users).then(function (users) &#123;\n&#x2F;&#x2F;     ajax(urls.users).then(function (users) &#123;\n&#x2F;&#x2F;       ajax(urls.users).then(function (users) &#123;\n&#x2F;&#x2F;         ajax(urls.users).then(function (users) &#123;\n\n&#x2F;&#x2F;         &#125;)\n&#x2F;&#x2F;       &#125;)\n&#x2F;&#x2F;     &#125;)\n&#x2F;&#x2F;   &#125;)\n&#x2F;&#x2F; &#125;)</code></pre>\n\n\n\n<h4 id=\"Promise-链式调用\"><a href=\"#Promise-链式调用\" class=\"headerlink\" title=\"Promise 链式调用\"></a>Promise 链式调用</h4><p>我们可以用 <code>promise.then()</code>，<code>promise.catch()</code> 和 <code>promise.finally()</code> 这些方法将进一步的操作与一个变为已敲定状态的 promise 关联起来。这些方法还会返回一个新生成的 promise 对象，这个对象可以被非强制性的用来做链式调用，就像这样：</p>\n<p><strong>以下所有示例中的ajax方法都在上面<code>Promise常见误区中</code>。</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\najax(&#39;&#x2F;api&#x2F;users.json&#39;)\n  .then(function (value) &#123;\n    console.log(1111)\n    return ajax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  &#125;) &#x2F;&#x2F; &#x3D;&gt; Promise\n  .then(function (value) &#123;\n    console.log(2222)\n    console.log(value)\n    return ajax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  &#125;) &#x2F;&#x2F; &#x3D;&gt; Promise\n  .then(function (value) &#123;\n    console.log(3333)\n    return ajax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  &#125;) &#x2F;&#x2F; &#x3D;&gt; Promise\n  .then(function (value) &#123;\n    console.log(4444)\n    return &#39;foo&#39;\n  &#125;) &#x2F;&#x2F; &#x3D;&gt; Promise\n\t.catch(function (value) &#123;\n    console.log(&#39;error&#39;, value)\n  &#125;)</code></pre>\n\n\n\n<h4 id=\"Promise-静态方法\"><a href=\"#Promise-静态方法\" class=\"headerlink\" title=\"Promise  静态方法\"></a>Promise  静态方法</h4><ul>\n<li><p>Promise.resolve(value)</p>\n<ul>\n<li>返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果您不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Promise.resolve(&#39;foo&#39;)\n  .then(function (value) &#123;\n    console.log(value) &#x2F;&#x2F; foo\n  &#125;)</code></pre></li>\n<li><p>Promise.reject(reason)</p>\n<ul>\n<li>返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; Promise.reject 传入任何值，都会作为这个 Promise 失败的理由\n\nPromise.reject(&#39;anything&#39;)\n  .catch(function (error) &#123;\n    console.log(error)\n  &#125;)\n\nPromise.reject(new Error(&#39;rejected&#39;))\n  .catch(function (error) &#123;\n    console.log(error)\n  &#125;)</code></pre></li>\n<li><p>Promise.all(iterable)</p>\n<ul>\n<li>这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 需要等待所有promise结束才会返回对应结果。\n&#x2F;&#x2F; 只有所有的promise都成功才能走.then()\n&#x2F;&#x2F; 否则走catch\nvar promise &#x3D; Promise.all([\n  ajax(&#39;&#x2F;api&#x2F;users.json&#39;),\n  ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)\n])\n\npromise.then(function (values) &#123;\n  console.log(values)\n&#125;).catch(function (error) &#123;\n  console.log(error\n&#125;</code></pre></li>\n<li><p>Promise.any(iterable)</p>\n<ul>\n<li>接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 只要有一个promise成功，立刻返回该成功的promise的值。\n&#x2F;&#x2F; 否则走catch\n\nvar promise &#x3D; Promise.all([\n  ajax(&#39;&#x2F;api&#x2F;users.json&#39;),\n  ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)\n])\n\npromise.then(function (values) &#123;\n  console.log(values)\n&#125;).catch(function (error) &#123;\n  console.log(error)\n&#125;</code></pre></li>\n<li><p>Promise.race(iterable)</p>\n<ul>\n<li>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 实现超时控制\n&#x2F;&#x2F; 如果 reauest 请求未得到响应，500毫秒内就触发定时器，返回reject\nconst request &#x3D; ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)\nconst timeout &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; reject(new Error(&#39;timeout&#39;)), 500)\n&#125;)\n\nPromise.race([\n  request,\n  timeout\n])\n.then(value &#x3D;&gt; &#123;\n  console.log(value)\n&#125;)\n.catch(error &#x3D;&gt; &#123;\n  console.log(error)\n&#125;)\n</code></pre></li>\n</ul>\n<h3 id=\"class-类\"><a href=\"#class-类\" class=\"headerlink\" title=\"class 类\"></a>class 类</h3>","text":"ES6新特性总结ps: 借鉴阮一峰老师的ECMAScript 6 入门；传送门，MDN文档；传送门 let、const、var关键字三个关键字的比较： var let Const 变量提升 √ × × 全局变量 √ × × 重复声明 √ × × 重新赋值 √ √ × 只声明不初始...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"web","slug":"web","count":5,"path":"api/categories/web.json"}],"tags":[{"name":"ES6","slug":"ES6","count":1,"path":"api/tags/ES6.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES6%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">ES6新特性总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#let%E3%80%81const%E3%80%81var%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">let、const、var关键字</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9A\"><span class=\"toc-text\">三个关键字的比较：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA%EF%BC%9F\"><span class=\"toc-text\">什么是暂时性死区？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#const%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%EF%BC%9A\"><span class=\"toc-text\">const关键字你不知道的事：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">变量的解构赋值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84\"><span class=\"toc-text\">数组的解构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E6%9E%84\"><span class=\"toc-text\">对象的解构</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E7%89%88%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">模版字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">字符串的扩展方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">箭头函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">对象的新增方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Object-assign\"><span class=\"toc-text\">1. Object.assign()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Object-is\"><span class=\"toc-text\">2.Object.is()</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Proxy\"><span class=\"toc-text\">Proxy</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">参数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Proxy-%E5%AF%B9%E6%AF%94-Object-defineProperty\"><span class=\"toc-text\">Proxy 对比 Object.defineProperty()</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise\"><span class=\"toc-text\">Promise</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">描述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">解决什么问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Promise-%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">Promise 基本示例</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Promise-%E6%96%B9%E5%BC%8F%E7%9A%84-AJAX\"><span class=\"toc-text\">Promise 方式的 AJAX</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Promise-%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA\"><span class=\"toc-text\">Promise 常见误区</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Promise-%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">Promise 链式调用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Promise-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Promise  静态方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#class-%E7%B1%BB\"><span class=\"toc-text\">class 类</span></a></li></ol></li></ol>","author":{"name":"黄振威","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3597257778138808","customs":{}}},"mapped":true,"prev_post":{"title":"闭包的概念及应用场景","uid":"00e349f9550fff228219dd858f639da6","slug":"javascript/bibao","date":"2021-09-26T12:30:40.078Z","updated":"2021-09-22T07:06:46.243Z","comments":true,"path":"api/articles/javascript/bibao.json","keywords":null,"cover":null,"text":"闭包的概念一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"web","slug":"web","count":5,"path":"api/categories/web.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":3,"path":"api/tags/JavaScript.json"}],"author":{"name":"黄振威","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/3597257778138808","customs":{}}}},"next_post":{}}