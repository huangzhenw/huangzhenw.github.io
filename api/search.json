[{"id":"6e40165d20a98baca2bd23d54541bc50","title":"深入分析前端性能优化及优化方案","content":"你是否经历过以下场景：\n\n面试中\n谈谈你对性能优化的理解\n输入URL整个页面经历了什么过程？\n…\n\n\n工作中\n页面加载好慢，不知道是前端问题还是后端问题\n页面交互卡顿，不知道具体哪里出了问题\n…\n\n\n\n如果有遇到此类型问题，希望我近期对性能优化的知识沉淀能够帮助到你，这篇文章先分析渲染过程，再分享优化方案。   \n首先将浏览器接受到URL后整个过程分为一下几大阶段：\n\n网络请求线程开启\n建立HTTP请求（DNS解析，TCP连接）\n前后端交互（后端处理流程，浏览器缓存）\n关键渲染路径（HTML，CSS，JS组织一起渲染）\n\n渲染过程分析网络请求线程开启浏览器接受到我们输入的URL到网络请求线程，这个阶段是在浏览器内部完成的。首先浏览器会对URL解析\n\n\n\n标题\n名称\n备注\n\n\n\nProtocol\n协议头\n说明浏览器该如何处理要打开的文件常见的有HTTP，FTP，Telnet\n\n\nHost\n主机域名/IP地址\n主机域名或经过DNS解析为IP地址\n\n\nPort\n端口号\n请求程序和相应程序之间连接用的标识\n\n\nPath\n目录路径\n请求的目录或文件名\n\n\nQuery\n查询参数\n请求所传递的参数\n\n\nFragment\n片段\n通常作为前端路由或锚点\n\n\nURL结构 Protocol://Host:Port/Path?Query#Fragment，示例：http://example.com/users/1?foo=bar#abc\n解析URL后，如果是HTTP协议，浏览器就会新建一个网络请求线程去下载所需的资源，对于线程和进程的学习，可以参考阮一峰老师的博客文章 线程和进程的一个简单解释 \nDNS解析DNS解析主要通过查询将URL中的HOST字段转化成网络中具体的IP地址，我们常看到的域名只是为了方便帮助记忆，IP地址才是所访问服务器在网络中的“门牌号”  \nDNS解析过程：\n流程图如下：\n首先查询浏览器自身的DNS缓存，如果查到IP地址就接受解析，如果浏览器缓存中没找到，就会搜索系统自身的DNS缓存，如果还没找到，接着尝试从系统中的hosts文件中查找。\n如果在本机主机进行的查询都没获取到，接下来便会到本地域名服务器上查询。如果也找不到，则本地域名服务器便会采取迭代的方式去依次查询根域名服务器、COM顶级域名服务器和权限域名服务器等，最终将所要访问的目标服务器IP地址放回到主机，此时，如果还是找不到该IP地址，则返回报错信息。\n由此可见，DNS解析过程是个很耗时的过程，如果需要解析的域名过多的话，势必会影响到首屏渲染时间。\nTCP连接经过DNS解析之后，接下来开始TCP连接，由于TCP是面向有连接的通信协议，所以在数据传输之前需要建立好客户端和服务端之间的连接，即通常说的“三次握手”。\n“三次握手”分析图：\n\n“三次握手”详细分析：\n\n第一次握手：客户端生成一个随机数seq，假设值为t，并将标志位SYN设置为1，将这些数据发送给服务器端，紧接着客户端进入等待状态。\n第二次握手：服务器端接受到客户端发来SYN=1后，服务器端就知道客户端在请求连接，就设置SYN和ACK均为1，并将客户端发送过来的seq的随机值t+1，赋值给ack，随后服务器端也生成一个随机数seq=k，将这些数据打包发送给客户端，作为对客户端请求连接的确认应答。\n第三次握手：客户端接收到服务器端发送过来的数据，检查ack是否为t+1，ACK是否等于1，若都正确，就将服务器端发送过来的seq随机数k+1赋值到ack，将这些数据发送给服务器端以确认服务器端的应答，服务器端根据ack是否等于k+1来决定是否建立连接。\n\n当用户关闭掉标签或者请求完成后，TCP连接就会进行“四次挥手“\n“四次挥手“分析图:\n\n“四次挥手”详细分析：\n\n第一次挥手： 先由客户端给服务器端发送FIN=M的指令，随后进入等待状态FIN_WAIT_1，表明客户端已经没有再向服务器端请求数据了，但若服务端器还有未完成的数据，可以继续发送。\n第二次挥手： 服务器端接受到客户端的FIN报文后，发送ack=M+1，告知客户端关闭请求已收到，但可能由于服务端器还有数据没发送完成，请客户端继续等待。\n第三次挥手： 当服务器端完成发送所有数据后，便发送带有FIN=N报文给客户端，通知准备关闭连接了，同时在等待客户端的最终关闭连接请求。\n第四次挥手： 客户端收到FIN=N报文后，可进行关闭操作，但是为了数据正确性，会回传一个ack=N+1给服务端，服务器端收到报文后才真正断开连接，客户端在发送了确认报文后一段时间，如果没有收到服务器端的任何信息，则认为服务器端连接已关闭，也可关闭客户端信息了。\n\n前后端交互在建立TCP连接成功后，便可通过HTTP等协议进行前后端的通信。\n后端处理流程：\n对于后端的处理细节，本人不是很了解，有兴趣的可以多去了解，但最终还是会以一个HTTP相应数据包的形式发送回给前端。\n浏览器缓存 （在后续优化方案中会详细说明使用方法）\n在HTTP的前后端交互过程中，使用缓存可以使性能得到显著提升，具体的缓存策略有两种：强缓存和协商缓存。\n强缓存：\n强缓存就是当浏览器判断出本地缓存还没过期时，直接读取本地缓存，无须发起HTTP请求。\n协商缓存：协商缓存则需要浏览器向服务器端发起HTTP请求，来判断浏览器本地缓存的文件是否还是未修改状态，如果还没修改，则从缓存中拿，如果已经被修改，则需要重新发送给浏览器。\n关键渲染路径（CRP）当我们经历了网络请求过程，从服务器获取到了所访问的页面文件后，浏览器如何将这些 HTML、CSS 及 JS 文件组织在一起渲染出来呢？\n构建对象模型\n首先浏览器会通过解析 HTML 和 CSS 文件，来构建 DOM（文档对象模型）和 CSSOM（层叠样式表对象模型）\n浏览器接收读取到的 HTML 文件来构建DOM（文档对象模型）大概预览图：\n\n浏览器接收读取到的 CSS 文件来构建CSSOM（层叠样式表对象模型）大概预览图：\n\n这两个对象模型的构建过程是会花费时间的，可以通过chrome浏览器打开开发者工具选项卡，查看对应过程的耗时情况，如图所示：\n\n渲染绘制\n当完成文档对象模型和层叠样式表对象模型的构建后，所得到的其实是描述最终渲染页面两个不同方面信息的对象：一个是展示的文档内容，另一个是文档对象对应的样式规则，接下来就需要将两个对象模型合并为渲染树，渲染树中只包含渲染可见的节点，该 HTML 文档最终生成的渲染树如图所示。\n\n渲染绘制的步骤大致如下：\n\n从所生成DOM树的根节点开始向下遍历每个子节点，忽略所有不可见的节点（JS脚本标记不可见，CSS隐藏不可见），因为不可见节点没有在渲染树中。\n在CSSOM中为每个节点找到对应的规则并应用。\n布局阶段，根据所得到的渲染树，计算他们在设备视图中的具体位置大小，这一步输出的是一个“盒模型”。\n绘制阶段，将每个节点的具体绘制方式转化为屏幕上的像素。\n\n优化方案请求和响应的优化DNS解析一般来说，在前端优化中与DNS有关的有两点：\n\n减少DNS的请求次数\n进行DNS进行预解析：DNS Prefetch\n\nDNS Prefetch\nDNS-prefetch (DNS 预获取) 是尝试在请求资源之前解析域名。这可能是后面要加载的文件，也可能是用户尝试打开的链接目标。域名解析和内容载入是串行的网络操作，所以这个方式能减少用户的等待时间，提升用户体验 。\n用法：\n&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;https:&#x2F;&#x2F;example.com&#x2F;&quot;&gt;\n\n注意事项：\n\ndns-prefetch仅对跨域域上的 DNS 查找有效，因此请避免使用它来指向您的站点或域。这是因为，到浏览器看到提示时，您站点域背后的IP已经被解析。\ndns-prefetch 需慎用，多页面重复 DNS 预解析会增加重复 DNS 查询次数。\n默认情况下浏览器会对页面中和当前域名（正在浏览网页的域名）不在同一个域的域名进行预获取，并且缓存结果，这就是隐式的 DNS Prefetch。如果想对页面中没有出现的域进行预获取，那么就要使用显示 DNS Prefetch 了。\n\nHTTP长连接短连接HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。\n比如，使用浏览器浏览一个包含多张图片的 HTMl 页面时，在发送请求访问 HTMl 页面资源的同时，也会请求该 HTML 页面包含的其它资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信录的开销。\n\n为了解决这个问题，有些浏览器在请求时，用了一个非标准的 Connection 字段。\nConnection: keep-alive\n\n这个字段要求服务器不要关闭 TCP 连接，以便其他请求复用。服务器同样回应这个字段。\n长连接1997 年 1 月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，直到现在还是最流行的版本。\nHTTP 1.1 版的最大变化，就是引入了持久连接（HTTP Persistent Connections），即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive\n\n持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早的结束，这样 Web 页面的显示速度也就相应提高了。\n管道机制HTTP 1.1 版还引入了管道机制（pipelining），即在同一个 TCP 连接里面，客户端可以同时发送多个请求。这样就进一步改进了 HTTP 协议的效率。\n从前发送请求后需等待并接收响应，才能发送下一个请求。管线化技术出现后，不用等待响应即可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个的等待响应了，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接还要快。请求数越多，时间差就越明显。\n\n举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应A请求，完成后再回应 B 请求。\nHTTP1.1长连接缺点虽然 HTTP 1.1 版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。\n为了避免这个问题，只有两种方法：\n\n一是减少请求数\n二是同时多开持久连接\n\n这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入 CSS 代码等等。\nHTTP22009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。\n多工HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。\n举例来说，在一个 TCP 连接里面，服务器同时收到了 A 请求和 B 请求，于是先回应 A 请求，结果发现处理过程非常耗时，于是就发送 A 请求已经处理好的部分， 接着回应 B 请求，完成后，再发送 A 请求剩下的部分。\n这样双向的、实时的通信，就叫做多工（Multiplexing）。\n这是一个对比 HTTP1 和 HTTP2 资源加载的在线示例：https://http2.akamai.com/demo\n数据流因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。\nHTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID 一律为奇数，服务器发出的，ID 为偶数。\n数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1 版取消数据流的唯一方法，就是关闭 TCP 连接。这就是说，HTTP/2 可以取消某一次请求，同时保证 TCP 连接还打开着，可以被其他请求使用。\n客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。\n头信息压缩HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。\nHTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。\n服务器推送HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。\n常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析 HTML 源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。\n压缩传输的数据资源数据压缩是提高 Web 站点性能的一种重要手段。对于有些文件来说，高达 70% 的压缩比率可以大大减低对于带宽的需求。随着时间的推移，压缩算法的效率也越来越高，同时也有新的压缩算法被发明出来，应用在客户端与服务器端。\nHTTP 响应数据压缩压缩 JS、CSS这里所说的压缩指的是去除换行空格之类的压缩，文件内容不变。\n使用 Gzip 压缩文本浏览器和服务器之间会使用主动协商机制。浏览器发送Accept-Encoding首部，其中包含有它所支持的压缩算法，以及各自的优先级，服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送Content-Encoding首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，在响应中，Vary首部中至少要包含Accept-Encoding；这样的话，缓存服务器就可以对资源的不同展现形式进行缓存。\n下面是一个请求响应的 HTTP 报文示例：\nGET &#x2F;encrypted-area HTTP&#x2F;1.1 \nHost: www.example.com \nAccept-Encoding: gzip, deflate\n\n\nHTTP&#x2F;1.1 200 OK \nDate: Tue, 27 Feb 2018 06:03:16 GMT \nServer: Apache&#x2F;1.3.3.7 (Unix) (Red-Hat&#x2F;Linux) \nLast-Modified: Wed, 08 Jan 2003 23:11:55 GMT \nAccept-Ranges: bytes \nContent-Length: 438 \nConnection: close \nContent-Type: text&#x2F;html; charset&#x3D;UTF-8 \nContent-Encoding: gzip\n\nHTTP 请求数据压缩头部数据压缩HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。\nHTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。\n请求体数据压缩实际的 Web 项目中，会存在请求正文非常大的场景，例如发表长篇博客，上报用于调试的网络数据等等。这些数据如果能在本地压缩后再提交，就可以节省网络流量、减少传输时间。如何对 HTTP 请求正文进行压缩，其中有如何在客户端压缩、如何在服务端解压两个部分。\n常用的三种数据压缩格式： DEFLATE、ZLIB、GZIP\n下面是一个简单示例。\n（1）压缩请求正文数据（客户端）\nvar rawBody &#x3D; &#39;content&#x3D;test&#39;; \nvar rawLen &#x3D; rawBody.length; \nvar bufBody &#x3D; new Uint8Array(rawLen); \nfor(var i &#x3D; 0; i &lt; rawLen; i++) &#123; \n    bufBody[i] &#x3D; rawBody.charCodeAt(i); \n&#125; \nvar format &#x3D; &#39;gzip&#39;; &#x2F;&#x2F; gzip | deflate | deflate-raw \nvar buf; \nswitch(format) &#123; \n    case &#39;gzip&#39;: \n        buf &#x3D; window.pako.gzip(bufBody); \n        break; \n    case &#39;deflate&#39;: \n        buf &#x3D; window.pako.deflate(bufBody); \n        break; \n    case &#39;deflate-raw&#39;: \n        buf &#x3D; window.pako.deflateRaw(bufBody); \n        break; \n&#125; \nvar xhr &#x3D; new XMLHttpRequest(); \nxhr.open(&#39;POST&#39;, &#39;&#x2F;node&#x2F;&#39;); \nxhr.setRequestHeader(&#39;Content-Encoding&#39;, format); \nxhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&#39;); \nxhr.send(buf);\n\n（2）在 Node 中解压请求正文中的数据（服务端）\nvar http &#x3D; require(&#39;http&#39;); \nvar zlib &#x3D; require(&#39;zlib&#39;); \nhttp.createServer(function (req, res) &#123; \n    var zlibStream; \n    var encoding &#x3D; req.headers[&#39;content-encoding&#39;]; \n    \n    switch(encoding) &#123; \n        case &#39;gzip&#39;: \n            zlibStream &#x3D; zlib.createGunzip(); \n            break; \n        case &#39;deflate&#39;: \n            zlibStream &#x3D; zlib.createInflate(); \n            break; \n        case &#39;deflate-raw&#39;: \n            zlibStream &#x3D; zlib.createInflateRaw();\n            break; \n    &#125; \n    \n    res.writeHead(200, &#123;&#39;Content-Type&#39;: &#39;text&#x2F;plain&#39;&#125;); \n    req.pipe(zlibStream).pipe(res); \n&#125;).listen(8361, &#39;127.0.0.1&#39;);\n\nHTTP缓存HTTP 缓存应该算是前端开发中最常接触的缓存机制之一，它又可细分为强制缓存与协商缓存，二者最大的区别在于判断缓存命中时，浏览器是否需要向服务器端进行询问以协商缓存的相关信息，进而判断是否需要就响应内容进行重新请求。下面就来具体看HTTP缓存的具体机制及缓存的决策策略。\n强制缓存对于强制缓存而言，如果浏览器判断所请求的目标资源有效命中，则可直接从强制缓存中返回请求响应，无须与服务器进行任何通信。\n在介绍强制缓存命中判断之前，我们首先来看一段响应头的部分信息：\naccess-control-allow-origin: * \nage: 734978 \ncontent-length: 40830 \ncontent-type: image&#x2F;jpeg \ncache-control: max-age&#x3D;31536000 \nexpires: Web, 14 Fed 2021 12:23:42 GMT\n\n其中与强制缓存相关的两个字段是expires和cache-control,expires是在 HTTP 1.0 协议中声明的用来控制缓存失效日期时间戳的字段，它由服务器端指定后通过响应头告知浏览器，浏览器在接收到带有该字段的响应体后进行缓存。\n若之后浏览器再次发起相同的资源请求，便会对比expires与本地当前的时间戳，如果当前请求的本地时间戳小于expires的值，则说明浏览器缓存的响应还未过期，可以直接使用而无须向服务器端再次发起请求。只有当本地时间戳大于expires值发生缓存过期时，才允许重新向服务器发起请求。\n从上述强制缓存是否过期的判断机制中不难看出，这个方式存在一个很大的漏洞，即对本地时间戳过分依赖，如果客户端本地的时间与服务器端的时间不同步，或者对客户端时间进行主动修改，那么对于缓存过期的判断可能就无法和预期相符。\n为了解决expires判断的局限性，从 HTTP 1.1 协议开始新增了cache-control字段来对expires的功能进行扩展和完善。从上述代码中可见cache-control设置了maxage=31536000的属性值来控制响应资源的有效期，它是一个以秒为单位的时间长度，表示该资源在被请求到后的 31536000 秒内有效，如此便可避免服务器端和客户端时间戳不同步而造成的问题。除此之外，cache-control还可配置一些其他属性值来更准确地控制缓存，下面来具体介绍。\nno-cache 和 no-store设置no-cache并非像字面上的意思不使用缓存，其表示为强制进行协商缓存（后面会说），即对于每次发起的请求都不会再去判断强制缓存是否过期，而是直接与服务器协商来验证缓存的有效性，若缓存未过期，则会使用本地缓存。设置no-store则表示禁止使用任何缓存策略，客户端的每次请求都需要服务器端给予全新的响应。no-cache和no-store是两个互斥的属性值，不能同时设置。\nCache-Control: no-store 响应头可以关闭缓存。\n指定Cache-Control: no-cache或Cache-Control: max-age=0表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。\n协商缓存协商缓存就是在使用本地缓存之前，需要向服务器端发起一次 GET 请求，与之协商当前浏览器保存的本地缓存是否已经过期。\n通常是采用所请求资源最近一次的修改时间戳来判断的，为了便于理解，下面来看一个例子：假设客户端浏览器需要向服务器请求一个manifest.js的 JavaScript 文件资源，为了让该资源被再次请求时能通过协商缓存的机制使用本地缓存，那么首次返回该图片资源的响应头中应包含一个名为last-modified的字段，该字段的属性值为该 JavaScript 文件最近一次修改的时间戳，简略截取请求头与响应头的关键信息如下：\nRequest URL: http:&#x2F;&#x2F;localhost:3000&#x2F;image.jpg \nRequest Method: GET \nlast-modified: Thu, 29 Apr 2021 03:09:28 GMT \ncache-control: no-cache\n\n当我们刷新网页时，由于该 JavaScript 文件使用的是协商缓存，客户端浏览器无法确定本地缓存是否过期，所以需要向服务器发送一次 GET 请求，进行缓存有效性的协商，此次 GET 请求的请求头中需要包含一个ifmodified-since字段，其值正是上次响应头中last-modified的字段值。当服务器收到该请求后便会对比请求资源当前的修改时间戳与if-modified-since字段的值，如果二者相同则说明缓存未过期，可继续使用本地缓存，否则服务器重新返回全新的文件资源，简略截取请求头与响应头的关键信息如下：\nRequest URL: http:&#x2F;&#x2F;localhost:3000&#x2F;image.jpg \nRequest Method: GET \nlast-modified: Thu, 29 Apr 2021 03:09:28 GMT \ncache-control: no-cache\n\n当我们刷新网页时，由于该 JavaScript 文件使用的是协商缓存，客户端浏览器无法确定本地缓存是否过期，所以需要向服务器发送一次 GET 请求，进行缓存有效性的协商，此次 GET 请求的请求头中需要包含一个ifmodified-since字段，其值正是上次响应头中last-modified的字段值。\n当服务器收到该请求后便会对比请求资源当前的修改时间戳与if-modified-since字段的值，如果二者相同则说明缓存未过期，可继续使用本地缓存，否则服务器重新返回全新的文件资源，简略截取请求头与响应头的关键信息如下：\n&#x2F;&#x2F; 再次请求的请求头 \nRequest URL: http:&#x2F;&#x2F;localhost:3000&#x2F;image.jpg \nRequest Method: GET \nIf-Modified-Since: Thu, 29 Apr 2021 03:09:28 GMT \n&#x2F;&#x2F; 协商缓存有效的响应头 \nStatus Code: 304 Not Modified\n\n这里需要注意的是，协商缓存判断缓存有效的响应状态码是304，即缓存有效响应重定向到本地缓存上。这和强制缓存有所不同，强制缓存若有效，则再次请求的响应状态码是200\nlast-modifed 的不足通过last-modified所实现的协商缓存能够满足大部分的使用场景，但也存在两个比较明显的缺陷：\n\n首先它只是根据资源最后的修改时间戳进行判断的，虽然请求的文件资源进行了编辑，但内容并没有发生任何变化，时间戳也会更新，从而导致协商缓存时关于有效性的判断验证为失效，需要重新进行完整的资源请求。这无疑会造成网络带宽资源的浪费，以及延长用户获取到目标资源的时间。\n\n其次标识文件资源修改的时间戳单位是秒，如果文件修改的速度非常快，假设在几百毫秒内完成，那么上述通过时间戳的方式来验证缓存的有效性，是无法识别出该次文件资源的更新的。\n\n\n其实造成上述两种缺陷的原因相同，就是服务器无法仅依据资源修改的时间戳来识别出真正的更新，进而导致重新发起了请求，该重新请求却使用了缓存的 Bug 场景。\n基于 ETag 的协商缓存为了弥补通过时间戳判断的不足，从 HTTP 1.1 规范开始新增了一个 ETag 的头信息，即实体标签（Entity Tag）。\n其内容主要是服务器为不同资源进行哈希运算所生成的一个字符串，该字符串类似于文件指纹，只要文件内容编码存在差异，对应的ETag标签值就会不同，因此可以使用对文件资源进行更精准的变化感知。下面我们来看一个使用ETag进行协商缓存图片资源的示例，首次请求后的部分响应头关键信息如下。\nContent-Type: image&#x2F;jpeg \nETag: &quot;xxx&quot; \nLast-Modified: Fri, 12 Jul 2021 18:30:00 GMT \nContent-Length: 9887\n\n上述响应头中同时包含了last-modified文件修改时间戳和 ETag 实体标签两种协商缓存的有效性校验字段，因为 ETag 比last-modified具有更准确的文件资源变化感知，所以它的优先级也更高，二者同时存在时以ETag为准。再次对该图片资源发起请求时，会将之前响应头中ETag的字段值作为此次请求头中If-None-Match字段，提供给服务器进行缓存有效性验证。请求头与响应头的关键字段信息如下。\n再次请求头：\nIf-Modified-Since: Fri, 12 Jul 2021 18:30:00 GMT \nIf-None-Match: &quot;xxx&quot; &#x2F;&#x2F; 上次ETag的值\n\n再次响应头：\nContent-Type: image&#x2F;jpeg ETag: &quot;xxx&quot; \nLast-Modified: Fri, 12 Jul 2021 18:30:00 GMT \nContent-Length: 9887\n\n若验证缓存有效，则返回304状态码响应重定向到本地缓存，所以上面响应头中的内容长度Content-Length字段值也就为 0 了。\nETag 的不足不像强制缓存中cache-control可以完全替代expires的功能，在协商缓存中，ETag并非last-modified的替代方案而是一种补充方案，因为它依旧存在一些弊端。\n\n一方面服务器对于生成文件资源的ETag需要付出额外的计算开销，如果资源的尺寸较大，数量较多且修改比较频繁，那么生成ETag的过程就会影响服务器的性能。\n另一方面ETag字段值的生成分为强验证和弱验证，强验证根据资源内容进行生成，能够保证每个字节都相同；弱验证则根据资源的部分属性值来生成，生成速度快但无法确保每个字节都相同，并且在服务器集群场景下，也会因为不够准确而降低协商缓存有效性验证的成功率，所以恰当的方式是根据具体的资源使用场景选择恰当的缓存校验方式。\n\n缓存决策示例在使用缓存技术优化性能体验的过程中，有一个问题是不可逾越的：我们既希望缓存能在客户端尽可能久的保存，又希望它能在资源发生修改时进行及时更新。\n这是两个互斥的优化诉求，使用强制缓存并定义足够长的过期时间就能让缓存在客户端长期驻留，但由于强制缓存的优先级高于协商缓存，所以很难进行及时更新；若使用协商缓存，虽然能够保证及时更新，但频繁与服务器进行协商验证的响应速度肯定不及使用强制缓存快。那么如何兼顾二者的优势呢？\n我们可以将一个网站所需要的资源按照不同类型去拆解，为不同类型的资源制定相应的缓存策略，以下面的HTML文件资源为例：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;title&gt;HTTP 缓存策略&lt;&#x2F;title&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;style.css&quot;&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt; \n    &lt;img src&#x3D;&quot;photo.jpg&quot; alt&#x3D;&quot;poto&quot;&gt;\n    &lt;script src&#x3D;&quot;script.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n\n该 HTML 文件中包含了一个 JavaScript 文件script.js、一个样式表文件style.css和一个图片文件photo.jpg，若要展示出该 HTML 中的内容就需要加载出其包含的所有外链文件。据此我们可针对它们进行如下设置。\n首先 HTML 在这里属于包含其他文件的主文件，为保证当其内容发生修改时能及时更新，应当将其设置为协商缓存，即为cache-control字段添加no-cache属性值；其次是图片文件，因为网站对图片的修改基本都是更换修改，同时考虑到图片文件的数量及大小可能对客户端缓存空间造成不小的开销，所以可采用强制缓存且过期时间不宜过长，故可设置cache-control字段值为max-age=86400。\n接下来需要考虑的是样式表文件style.css，由于其属于文本文件，可能存在内容的不定期修改，又想使用强制缓存来提高重用效率，故可以考虑在样式表文件的命名中增加文件指纹或版本号（比如添加文件指纹后的样式表文件名变为了style.51ad84f7.css），这样当发生文件修改后，不同的文件便会有不同的文件指纹，即需要请求的文件 URL 不同了，因此必然会发生对资源的重新请求。\n最后是 JavaScript 脚本文件，其可类似于样式表文件的设置。\n从这个缓存策略的示例中我们可以看出，对不同资源进行组合使用强制缓存、协商缓存及文件指纹或版本号，可以做到一举多得：及时修改更新、较长缓存过期时间及控制所能进行缓存的位置。\n代码示例node.js为例\nconst http &#x3D; require(&#39;http&#39;)\nconst fs &#x3D; require(&#39;fs&#39;)\nconst url &#x3D; require(&#39;url&#39;)\nconst etag &#x3D; require(&#39;etag&#39;)\n\nhttp.createServer((req, res) &#x3D;&gt; &#123;\n    console.log(req.method, req.url)\n    const &#123; pathname &#125; &#x3D; url.parse(req.url)\n    if (pathname &#x3D;&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;\n        const data &#x3D; fs.readFileSync(&#39;.&#x2F;index.html&#39;)\n        res.end(data)\n    &#125; else if (pathname &#x3D;&#x3D;&#x3D; &#39;&#x2F;img&#x2F;01.jpg&#39;) &#123; &#x2F;&#x2F; 强缓存-Expires\n        const data &#x3D; fs.readFileSync(&#39;.&#x2F;img&#x2F;01.jpg&#39;)\n        res.writeHead(200, &#123;\n            &#x2F;&#x2F; 缺点：客户端时间和服务器时间可能不同步\n            Expires: new Date(&#39;2021-08-01 00:46&#39;).toUTCString()\n        &#125;)\n        res.end(data)\n    &#125; else if (pathname &#x3D;&#x3D;&#x3D; &#39;&#x2F;img&#x2F;02.jpg&#39;) &#123;  &#x2F;&#x2F; 强缓存 Cache-Control: max-age &#x3D; 5\n        const data &#x3D; fs.readFileSync(&#39;.&#x2F;img&#x2F;02.jpg&#39;)\n        res.writeHead(200, &#123;\n            &#39;Cache-Control&#39;: &#39;max-age&#x3D;5&#39; &#x2F;&#x2F; 滑动时间，单位是秒\n        &#125;)\n        res.end(data)\n    &#125; else if (pathname &#x3D;&#x3D;&#x3D; &#39;&#x2F;img&#x2F;03.jpg&#39;) &#123;\n        const &#123; mtime &#125; &#x3D; fs.statSync(&#39;.&#x2F;img&#x2F;03.jpg&#39;)\n\n        const ifModifiedSince &#x3D; req.headers[&#39;if-modified-since&#39;]\n\n        if (ifModifiedSince &#x3D;&#x3D;&#x3D; mtime.toUTCString()) &#123;\n            &#x2F;&#x2F; 缓存生效\n            res.statusCode &#x3D; 304\n            res.end()\n            return\n        &#125;\n\n        const data &#x3D; fs.readFileSync(&#39;.&#x2F;img&#x2F;03.jpg&#39;)\n\n        &#x2F;&#x2F; 告诉客户端该资源要使用协商缓存\n        &#x2F;&#x2F;   客户端使用缓存数据之前问一下服务器缓存有效吗\n        &#x2F;&#x2F;   服务端：\n        &#x2F;&#x2F;     有效：返回 304 ，客户端使用本地缓存资源\n        &#x2F;&#x2F;     无效：直接返回新的资源数据，客户端直接使用\n        res.setHeader(&#39;Cache-Control&#39;, &#39;no-cache&#39;)\n        &#x2F;&#x2F; 服务端要下发一个字段告诉客户端这个资源的更新时间\n        res.setHeader(&#39;last-modified&#39;, mtime.toUTCString())\n        res.end(data)\n    &#125; else if (pathname &#x3D;&#x3D;&#x3D; &#39;&#x2F;img&#x2F;04.jpg&#39;) &#123;\n        const data &#x3D; fs.readFileSync(&#39;.&#x2F;img&#x2F;04.jpg&#39;)\n        &#x2F;&#x2F; 基于文件内容生成一个唯一的密码戳\n        const etagContent &#x3D; etag(data)\n\n        const ifNoneMatch &#x3D; req.headers[&#39;if-none-match&#39;]\n\n        if (ifNoneMatch &#x3D;&#x3D;&#x3D; etagContent) &#123;\n            res.statusCode &#x3D; 304\n            res.end()\n            return\n        &#125;\n\n        &#x2F;&#x2F; 告诉客户端要进行协商缓存\n        res.setHeader(&#39;Cache-Control&#39;, &#39;no-cache&#39;)\n        &#x2F;&#x2F; 把该资源的内容密码戳发给客户端\n        res.setHeader(&#39;etag&#39;, etagContent)\n        res.end(data)\n    &#125; else &#123;\n        res.statusCode &#x3D; 404\n        res.end()\n    &#125;\n&#125;).listen(3000, () &#x3D;&gt; &#123;\n    console.log(&#39;http:&#x2F;&#x2F;localhost:3000&#39;)\n&#125;)\n\n渲染优化关键渲染路径优化浏览器从获取 HTML 到最终在屏幕上显示内容需要完成以下步骤：\n\n处理 HTML 标记并构建 DOM 树。\n处理 CSS 标记并构建 CSSOM 树。\n将 DOM 与 CSSOM 合并成一个 render tree。\n根据渲染树来布局，以计算每个节点的几何信息。\n将各个节点绘制到屏幕上。\n\n经过以上整个流程我们才能看见屏幕上出现渲染的内容，优化关键渲染路径就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间，让用户最快的看到首次渲染的内容。\n为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：\n\n关键资源的数量。\n关键路径长度。\n关键字节的数量。\n\n关键资源是可能阻止网页首次渲染的资源。例如 JavaScript、CSS 都是可以阻塞关键渲染路径的资源，这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。\n同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响: 某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。\n最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。\n优化 DOM在关键渲染路径中，构建渲染树（Render Tree）的第一步是构建 DOM，所以我们先讨论如何让构建 DOM 的速度变得更快。\nHTML 文件的尺寸应该尽可能的小，目的是为了让客户端尽可能早的接收到完整的 HTML。通常 HTML 中有很多冗余的字符，例如：JS 注释、CSS 注释、HTML 注释、空格、换行。更糟糕的情况是我见过很多生产环境中的 HTML 里面包含了很多废弃代码，这可能是因为随着时间的推移，项目越来越大，由于种种原因从历史遗留下来的问题，不过不管怎么说，这都是很糟糕的。对于生产环境的HTML来说，应该删除一切无用的代码，尽可能保证 HTML 文件精简。\n总结起来有三种方式可以优化 HTML：缩小文件的尺寸（Minify）、使用gzip压缩（Compress）、使用缓存（HTTP Cache）\n本质上，优化 DOM 其实是在尽可能的减小关键路径的长度与关键字节的数量。\n优化 CSSOMCSS 是构建渲染树的必备元素，首次构建网页时，JavaScript 常常受阻于 CSS。确保将任何非必需的 CSS 都标记为非关键资源（例如打印和其他媒体查询），并应确保尽可能减少关键 CSS 的数量，以及尽可能缩短传送时间。\n阻塞渲染的 CSSCSS 是关键资源，它会阻塞关键渲染路径也并不奇怪，但通常并不是所有的 CSS 资源都那么的『关键』。\n举个例子：一些响应式 CSS 只在屏幕宽度符合条件时才会生效，还有一些 CSS 只在打印页面时才生效。这些 CSS 在不符合条件时，是不会生效的，所以我们为什么要让浏览器等待我们并不需要的 CSS 资源呢？\n针对这种情况，我们应该让这些非关键的 CSS 资源不阻塞渲染。\n&lt;link href&#x3D;&quot;style.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt; \n&lt;link href&#x3D;&quot;print.css&quot; rel&#x3D;&quot;stylesheet&quot; media&#x3D;&quot;print&quot;&gt; \n&lt;link href&#x3D;&quot;other.css&quot; rel&#x3D;&quot;stylesheet&quot; media&#x3D;&quot;(min-width: 40em)&quot;&gt; \n&lt;link href&#x3D;&quot;portrait.css&quot; rel&#x3D;&quot;stylesheet&quot; media&#x3D;&quot;orientation:portrait&quot;&gt;\n\n\n第一个声明阻塞渲染，适用于所有情况。\n第二个声明只在打印网页时应用，因此网页首次在浏览器中加载时，它不会阻塞渲染。\n声明提供由浏览器执行的“媒体查询”: 符合条件时，浏览器将阻塞渲染，直至样式表下载并处理完毕。\n最后一个声明具有动态媒体查询，将在网页加载时计算。根据网页加载时设备的方向，portrait.css 可能阻塞渲染，也可能不阻塞渲染。\n\n最后，请注意“阻塞渲染”仅是指浏览器是否需要暂停网页的首次渲染，直至该资源准备就绪。无论哪一种情况，浏览器仍会下载 CSS 资产，只不过不阻塞渲染的资源优先级较低罢了。\n为获得最佳性能，您可能会考虑将关键 CSS 直接内联到 HTML 文档内。这样做不会增加关键路径中的往返次数，并且如果实现得当，在只有 HTML 是阻塞渲染的资源时，可实现“一次往返”关键路径长度。\n避免在 CSS 中使用@import大家应该都知道要避免使用@import加载 CSS，实际工作中我们也不会这样去加载 CSS，但这到底是为什么呢？\n这是因为使用@import加载 CSS 会增加额外的关键路径长度。举个例子：\n&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Demos&lt;&#x2F;title&gt;\n  &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:8887&#x2F;style.css&quot;&gt;\n  &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;lib.baomitu.com&#x2F;CSS-Mint&#x2F;2.0.6&#x2F;css-mint.min.css&quot;&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n  &lt;div class&#x3D;&quot;cm-alert&quot;&gt;Default alert&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n上面这段代码使用link标签加载了两个 CSS 资源。这两个 CSS 资源是并行下载的。\n现在我们改为使用@import加载资源，代码如下：\n&#x2F;* style.css *&#x2F; \n@import url(&#39;https:&#x2F;&#x2F;lib.baomitu.com&#x2F;CSS-Mint&#x2F;2.0.6&#x2F;css-mint.min.css&#39;); \nbody&#123;\n    background:red;\n&#125;\n\n\n&lt;!doctype html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Demos&lt;&#x2F;title&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:8887&#x2F;style.css&quot;&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;div class&#x3D;&quot;cm-alert&quot;&gt;Default alert&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n代码中使用 link 标签加载一个 CSS，然后在 CSS 文件中使用@import加载另一个 CSS。\n可以看到两个 CSS 变成了串行加载，前一个 CSS 加载完后再去下载使用@import导入的 CSS 资源。这无疑会导致加载资源的总时间变长。从上图可以看出，首次绘制时间等于两个 CSS 资源加载时间的总和。\n所以避免使用@import是为了降低关键路径的长度。\n优化 JavaScript 的使用所有文本资源都应该让文件尽可能的小，JavaScript 也不例外，它也需要删除未使用的代码、缩小文件的尺寸（Minify）、使用 gzip 压缩（Compress）、使用缓存（HTTP Cache）。\n\n异步加载 JavaScript\n避免同步请求\n延迟解析 JavaScript\n避免运行时间长的 JavaScript\n\n使用 defer 延迟加载 JavaScript与 CSS 资源相似，JavaScript 资源也是关键资源，JavaScript 资源会阻塞 DOM 的构建。并且 JavaScript 会被 CSS 文件所阻塞。\n当浏览器加载 HTML 时遇到&lt;script&gt;...&lt;/script&gt;标签，浏览器就不能继续构建 DOM。它必须立刻执行此脚本。对于外部脚本&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;也是一样的：浏览器必须等脚本下载完，并执行结束，之后才能继续处理剩余的页面。\n这会导致两个重要的问题：\n\n脚本不能访问到位于它们下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。\n如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容\n\n&lt;p&gt;...content before script...&lt;&#x2F;p&gt;\n\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;javascript.info&#x2F;article&#x2F;script-async-defer&#x2F;long.js?speed&#x3D;1&quot;&gt;&lt;&#x2F;script&gt;\n\n&lt;!-- This isn&#39;t visible until the script loads --&gt;\n&lt;p&gt;...content after script...&lt;&#x2F;p&gt;\n\n这里有一些解决办法。例如，我们可以把脚本放在页面底部。此时，它可以访问到它上面的元素，并且不会阻塞页面显示内容：\n&lt;body&gt;\n  ...all content is above the script...\n\n  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;javascript.info&#x2F;article&#x2F;script-async-defer&#x2F;long.js?speed&#x3D;1&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n但是这种解决方案远非完美。例如，浏览器只有在下载了完整的 HTML 文档之后才会注意到该脚本（并且可以开始下载它）。对于长的 HTML 文档来说，这样可能会造成明显的延迟。\n这对于使用高速连接的人来说，这不值一提，他们不会感受到这种延迟。但是这个世界上仍然有很多地区的人们所使用的网络速度很慢，并且使用的是远非完美的移动互联网连接。\n幸运的是，这里有两个script特性（attribute）可以为我们解决这个问题：defer和async。\ndefer特性告诉浏览器不要等待脚本。相反，浏览器将继续处理 HTML，构建 DOM。脚本会“在后台”下载，然后等 DOM 构建完成后，脚本才会执行。\n这是与上面那个相同的示例，但是带有defer特性：\n&lt;p&gt;...content before script...&lt;&#x2F;p&gt;\n\n&lt;script defer src&#x3D;&quot;https:&#x2F;&#x2F;javascript.info&#x2F;article&#x2F;script-async-defer&#x2F;long.js?speed&#x3D;1&quot;&gt;&lt;&#x2F;script&gt;\n\n&lt;!-- 立即可见 --&gt;\n&lt;p&gt;...content after script...&lt;&#x2F;p&gt;\n\n换句话说：\n\n具有 defer 特性的脚本不会阻塞页面。\n具有 defer 特性的脚本总是要等到 DOM 解析完毕。\n\n具有 defer 特性的脚本保持其相对顺序，就像常规脚本一样。\n假设，我们有两个具有 defer 特性的脚本：long.js 在前，small.js 在后。\n&lt;script defer src&#x3D;&quot;https:&#x2F;&#x2F;javascript.info&#x2F;article&#x2F;script-async-defer&#x2F;long.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script defer src&#x3D;&quot;https:&#x2F;&#x2F;javascript.info&#x2F;article&#x2F;script-async-defer&#x2F;small.js&quot;&gt;&lt;&#x2F;script&gt;\n\n浏览器扫描页面寻找脚本，然后并行下载它们，以提高性能。因此，在上面的示例中，两个脚本是并行下载的。small.js 可能会先下载完成。\n……但是，defer 特性除了告诉浏览器“不要阻塞页面”之外，还可以确保脚本执行的相对顺序。因此，即使 small.js 先加载完成，它也需要等到 long.js 执行结束才会被执行。\n当我们需要先加载 JavaScript 库，然后再加载依赖于它的脚本时，这可能会很有用。\n使用 async 延迟加载 JavaScriptasync 特性与 defer 有些类似。它也能够让脚本不阻塞页面。但是，在行为上二者有着重要的区别。\nasync 特性意味着脚本是完全独立的： \n\n浏览器不会因 async 脚本而阻塞（与 defer 类似）。\n其他脚本不会等待 async 脚本加载完成，同样，async 脚本也不会等待其他脚本。\n\n换句话说，async 脚本会在后台加载，并在加载就绪时运行。DOM 和其他脚本不会等待它们，它们也不会等待其它的东西。async 脚本就是一个会在加载完成时执行的完全独立的脚本。\n资源加载优化图片延迟加载什么是延迟加载首先来想象一个场景，当浏览一个内容丰富的网站时，比如电商的商品列表页、主流视频网站的节目列表等，由于屏幕尺寸的限制，每次只能查看到视窗中的那部分内容，而要浏览完页面所包含的全部信息，就需要滚动页面，让屏幕视窗依次展示出整个页面的所有局部内容。\n显而易见，对于首屏之外的内容，特别是图片和视频，一方面由于资源文件很大，若是全部加载完，既费时又费力，还容易阻塞渲染引起卡顿；另一方面，就算加载完成，用户也不一定会滚动屏幕浏览到全部页面内容，如果首屏内容没能吸引住用户，那么很可能整个页面就将遭到关闭。\n既然如此，本着节约不浪费的原则，在首次打开网站时，应尽量只加载首屏内容所包含的资源，而首屏之外涉及的图片或视频，可以等到用户滚动视窗浏览时再去加载。\n以上就是延迟加载优化策略的产生逻辑，通过延迟加载“非关键”的图片及视频资源，使得页面内容更快地呈现在用户面前。这里的“非关键”资源指的就是首屏之外的图片或视频资源，相较于文本、脚本等其他资源来说，图片的资源大小不容小觑。\n实现图片延迟加载参考阮一峰老师的博客文章intersectionobserver_api\n图片优化\n适合用矢量图的地方首选矢量图。\n使用位图时首选WebP，对不支持的浏览器场景进行兼容处理。\n尽量为位图图像格式找到最佳质量设置。\n对图像文件进行必要的压缩。\n为图像提供多种缩放尺寸的响应式资源。\n对工程化通用图像处理流程尽量自动化。\n\n构建优化\nwebpack 优化\n代码拆分\n代码压缩\n持久化缓存\n监测与分析\n按需加载\n\n","slug":"performance/performance","date":"2021-09-26T12:30:40.101Z","categories_index":"web","tags_index":"前端性能优化","author_index":"黄振威"},{"id":"aebc5a3f3b331af7862288aae1caccd0","title":"Promise原理分析、手写Promise简易版","content":"一、前言Promise灵魂三问：是什么？做什么？怎么做？\n\n是什么？—-Promise 是异步编程的一种解决方案，ES6新增的一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。\n做什么？—-Promise 解决回调地狱的问题，在多层嵌套的回调方法中，如果同时存在同步、异步的方法，那么实际执行顺序会混乱，不好调试不好维护。\n怎么做？ 3.1 假设有一个需求，对接服务端接口时，想要拿到接口url 为 ‘url5’ 返回的data5，但是url5需要根据url4返回的数据作为参数，url4又需要url3返回的数据作为参数，以此类推 ······(嵌套层级略微夸张了一点点，但实际开发中经常出现类似这种依赖上一个接口返回的数据作为下一个接口的传递参数） 不使用`Promise`处理方案：\n\n $.get(&#39;&#x2F;url1&#39;, function (data1) &#123;\n  $.get(&#39;&#x2F;url2&#39;, data1, function (data2) &#123;\n    $.get(&#39;&#x2F;url3&#39;, data2, function (data3) &#123;\n      $.get(&#39;&#x2F;url4&#39;, data3, function (data4) &#123;\n        $.get(&#39;&#x2F;url5&#39;, data4, function (data5) &#123;\n            console.log(data5) \n          &#125;)\n      &#125;)\n    &#125;)\n  &#125;)\n&#125;)\n使用Promise处理方案： let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  $.get(&#39;&#x2F;url1&#39;, data1 &#x3D;&gt; &#123;\n    resolve(data1)\n  &#125;)\n&#125;)\n   \npromise.then((data1) &#x3D;&gt; &#123;\n  $.get(&#39;&#x2F;url2&#39;, data1, data2 &#x3D;&gt; &#123;\n    return data2\n  &#125;)\n&#125;).then((data2) &#x3D;&gt; &#123;\n  $.get(&#39;&#x2F;url3&#39;, data2, data3 &#x3D;&gt; &#123;\n    return data3\n  &#125;)\n&#125;).then((data3) &#x3D;&gt; &#123;\n  $.get(&#39;&#x2F;url4&#39;, data3, data4 &#x3D;&gt; &#123;\n    console.log(data4)\n  &#125;)\n&#125;)\n\n二、Promise使用原理分析\nPromise 就是一个类，在执行这个类的时候，需要传递一个执行器进去，执行器会立即执行\nPromise 中有三种状态，分别为 等待pending， 成功 fulfilled ，失败 rejected pending -&gt; fulfilled pending -&gt; rejected 状态一旦确定就不可更改\nresolve和reject函数是用来更改状态的 resolve：fulfilled reject：rejected\nthen方法内部做的事情就判断状态 如果状态是成功就调用成功的回调函数 如果状态是失败，就调用失败的回调函数 then方法是定义在原型对象当中\nthen成功回调有一个参数 表示成功之后的值 then失败回调用一个参数，表示失败后的原因\n\n三、手写Pormise\n创建Mypromise.js文件，根据上述1. 2. 3. 原理分析，我们定义三种状态，创建一个MyPromise的类，执行器立即执行，初始化状态为PENDING，定义resolve，reject 方法，代码如下：\n\nconst PENDING &#x3D; &quot;pending&quot; &#x2F;&#x2F;等待\nconst FULFILLED &#x3D; &quot;fulfilled&quot; &#x2F;&#x2F;成功\nconst REJECT &#x3D; &quot;reject&quot; &#x2F;&#x2F;失败\n\nclass MyPromise &#123;\n  constructor(executor) &#123;\n    executor(this.resolve, this.reject)\n  &#125;\n  &#x2F;&#x2F; 初始状态  等待\n  status &#x3D; PENDING\n\n  resolve &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果状态不是等待 阻止程序向下执行\n    if (this.status !&#x3D;&#x3D; PENDING) return\n    &#x2F;&#x2F; 将状态更改为成功\n    this.status &#x3D; FULFILLED\n  &#125;\n  reject &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果状态不是等待 阻止程序向下执行\n    if (this.status !&#x3D;&#x3D; PENDING) return\n    &#x2F;&#x2F; 将状态更改为失败\n    this.status &#x3D; REJECT\n  &#125;\n&#125;\n\n根据上诉4. 5.原理分析，我们需要定义then方法，主要是判断当前状态调用成功或者失败的函数，需要提前声明successCallback和failCallback分别为成功和失败的回调函数，回调函数中需要传递成功的值value或者传递错误信息reason，因此value和reason需要提前声明，代码如下：\n\n&#x2F;&#x2F; 声明成功返回的初始值\nvalue &#x3D; undefined\n&#x2F;&#x2F; 声明失败返回的原因\nreason &#x3D; undefined\n&#x2F;&#x2F; 声明成功回调函数\nsuccessCallback &#x3D; undefined\n&#x2F;&#x2F; 声明失败回调函数\nfailCallback &#x3D; undefined\nthen (successCallback, failCallback) &#123;\n    if (this.status &#x3D;&#x3D;&#x3D; FULFILLED) &#123;\n      successCallback(this.value)\n    &#125; else if (this.status &#x3D;&#x3D;&#x3D; REJECT) &#123;\n      failCallback(this.reason)\n    &#125;\n&#125;\n因为我们then方法中successCallback和failCallback回调函数中需要用上value和reason的值作为参数传递，所以我们应该在resolve和reject中分别保存接受到的value和reason，代码修改如下：\nresolve &#x3D; value &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果状态不是等待 阻止程序向下执行\n    if (this.status !&#x3D;&#x3D; PENDING) return\n    &#x2F;&#x2F; 将状态更改为成功\n    this.status &#x3D; FULFILLED\n    &#x2F;&#x2F; 保存成功之后的值，传递给then方法\n    this.value &#x3D; value\n    &#125;\n    reject &#x3D; reason &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果状态不是等待 阻止程序向下执行\n    if (this.status !&#x3D;&#x3D; PENDING) return\n    &#x2F;&#x2F; 将状态更改为失败\n    this.status &#x3D; REJECT\n    &#x2F;&#x2F; 保存失败之后的原因，传递给then方法\n    this.reason &#x3D; reason\n&#125;\n此时，基础简易版已经完成，需要module.exports = MyPromise导出\n四、最终代码和使用MyPromise.js\nconst PENDING &#x3D; &quot;pending&quot; &#x2F;&#x2F;等待\nconst FULFILLED &#x3D; &quot;fulfilled&quot; &#x2F;&#x2F;成功\nconst REJECT &#x3D; &quot;reject&quot; &#x2F;&#x2F;失败\n\nclass MyPromise &#123;\n  constructor(executor) &#123;\n    executor(this.resolve, this.reject)\n  &#125;\n  &#x2F;&#x2F; 初始状态  等待\n  status &#x3D; PENDING\n  &#x2F;&#x2F; 声明成功返回的初始值\n  value &#x3D; undefined\n  &#x2F;&#x2F; 声明失败返回的原因\n  reason &#x3D; undefined\n  &#x2F;&#x2F; 声明成功回调函数\n  successCallback &#x3D; undefined\n  &#x2F;&#x2F; 声明失败回调函数\n  failCallback &#x3D; undefined\n  resolve &#x3D; value &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果状态不是等待 阻止程序向下执行\n    if (this.status !&#x3D;&#x3D; PENDING) return\n    &#x2F;&#x2F; 将状态更改为成功\n    this.status &#x3D; FULFILLED\n    &#x2F;&#x2F; 保存成功之后的值，传递给then方法\n    this.value &#x3D; value\n  &#125;\n  reject &#x3D; reason &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果状态不是等待 阻止程序向下执行\n    if (this.status !&#x3D;&#x3D; PENDING) return\n    &#x2F;&#x2F; 将状态更改为失败\n    this.status &#x3D; REJECT\n    &#x2F;&#x2F; 保存失败之后的原因，传递给then方法\n    this.reason &#x3D; reason\n  &#125;\n  then (successCallback, failCallback) &#123;\n    if (this.status &#x3D;&#x3D;&#x3D; FULFILLED) &#123;\n      successCallback(this.value)\n    &#125; else if (this.status &#x3D;&#x3D;&#x3D; REJECT) &#123;\n      failCallback(this.reason)\n    &#125;\n  &#125;\n&#125;\n\nmodule.exports &#x3D; MyPromise\n创建index.js导入我们的Pormise类并使用它，代码如下：\nconst MyPromise &#x3D; require(&#39;.&#x2F;MyPromise&#39;)\n\nlet promise &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;\n  resolve(&#39;成功值&#39;)\n  &#x2F;&#x2F; reject(&#39;失败信息&#39;)\n&#125;)\npromise.then(value &#x3D;&gt; &#123;\n  console.log(value) &#x2F;&#x2F; 成功值\n&#125;, reason &#x3D;&gt; &#123;\n  console.log(reason) &#x2F;&#x2F; 失败信息\n&#125;)\n\n在控制台中输入node index.js启动\n","slug":"javascript/promise","date":"2021-09-26T12:30:40.085Z","categories_index":"web","tags_index":"JavaScript","author_index":"黄振威"},{"id":"b4572855b594ba24ba1854f956bab41e","title":"浅谈JS运行机制，宏任务，微任务","content":"JS 单线程先聊聊JS的单线程工作，单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。\n那怎么样解决这种问题呢，在浏览器平台下，浏览器底层开启了多线程去执行了一些任务，形成了我们常说的异步任务，比如说定时器setTimeout，异步任务可以很好的解决代码阻塞问题，但这也会带来代码的执行顺序没有像同步任务那样直观明了，这也是我们本文的重点。\nJS 运行机制一开始整个脚本作为一个宏任务执行。执行过程中同步代码直接执行，宏任务等待时间到达或者成功后，将方法的回调放入宏任务队列中，微任务进入微任务队列。\n当前主线程的宏任务执行完出队，检查并清空微任务队列。接着执行浏览器 UI 线程的渲染工作，检查web worker 任务，有则执行。\n然后再取出一个宏任务执行。以此循环…\nEventLoop 是一种循环机制 ，不断去轮询一些队列 ，从中找到需要执行的任务并按顺序执行的一个执行模型。\n宏任务与微任务宏任务可以理解为每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。\n浏览器为了让 JS 内部宏任务 与 DOM 操作能够有序的执行，会在一个宏任务执行结束后，在下一个宏任务执行开始前，对页面进行重新渲染。\n宏任务包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、MessageChannel 等。\n 微任务可以理解是在当前任务执行结束后需要立即执行的任务。也就是说，在当前任务后，在渲染之前，执行清空微任务。\n  所以它的响应速度相比宏任务会更快，因为无需等待 UI 渲染。\n  微任务包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)等。\n代码示例console.log(&#39;start&#39;)\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;s1&#39;)\n  Promise.resolve().then(() &#x3D;&gt; &#123;\n    console.log(&#39;p2&#39;)\n  &#125;)\n  Promise.resolve().then(() &#x3D;&gt; &#123;\n    console.log(&#39;p3&#39;)\n  &#125;)\n&#125;)\n\nPromise.resolve().then(() &#x3D;&gt; &#123;\n  console.log(&#39;p1&#39;)\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;s2&#39;)\n  &#125;)\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;s3&#39;)\n  &#125;)\n&#125;)\nconsole.log(&#39;end&#39;)\n\n\n代码分析EventLoop\n首先遇到 console.log(&#39;start&#39;) ，输出 start，继续执行。\n遇到 setTimeout，由于 setTimeout 是宏任务，时间到了将其放入宏任务队列中，继续执行。\n遇到 Promise.then ，由于当前是微任务，将其放入微任务队列中，继续执行。\n遇到 console.log(&#39;end&#39;) ，输出 end。\n此时，当前主线程中的任务已全部执行完毕， EventLoop 就开始工作，找需要执行的任务压入到执行栈中，微任务优先于宏任务，因此先把 Promise.resolve().then 压入到执行栈开始继续执行。\n遇到 console.log(&#39;p1&#39;) ，输出 p1 ，继续执行。\n遇到两个 setTimeout  s2，s3， 放入到宏任务队列中等待执行。\n此时，当前主线程中的任务又全部执行完毕，检查并清空微任务队列，由于此时没有微任务，然后就取出之前第2步骤的宏任务 setTimeout 开始执行。\n输出 s1 ，紧接着又遇到 p2 ， p3两个微任务，将其放入微任务队列中。\n此时，当前主线程中的任务又全部执行完毕，检查并清空微任务队列。所以相继输出 p2 ， p3。\n此时，当前主线程中的任务又全部执行完毕，检查并清空微任务队列，由于此时没有微任务，然后就取出之前第7步骤的宏任务 setTimeout 开始执行。所以相继输出 s2 ， s3。\n整个js代码已全部完毕，最终输出顺序 start， end， p1，s1，p2 ，p3， s2， s3。\n\n","slug":"javascript/jsyxjz","date":"2021-09-26T12:30:40.082Z","categories_index":"web","tags_index":"JavaScript","author_index":"黄振威"},{"id":"00e349f9550fff228219dd858f639da6","title":"闭包的概念及应用场景","content":"闭包的概念一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。—摘自于MDN上对闭包的解释，前往MDN-闭包。\n通俗点说就是：只要一个函数访问了一个不属于当前函数作用域的变量就称为闭包。\n下面看一个MDN上简单的例子：\nfunction init() &#123;\n    var name &#x3D; &quot;Mozilla&quot;; &#x2F;&#x2F; name 是一个被 init 创建的局部变量\n    function displayName() &#123; &#x2F;&#x2F; displayName() 是内部函数，一个闭包\n        alert(name); &#x2F;&#x2F; 使用了父函数中声明的变量\n    &#125;\n    displayName();\n&#125;\ninit();\n\ninit() 创建了一个局部变量 name 和一个名为 displayName() 的函数。displayName() 是定义在 init() 里的内部函数，并且仅在 init() 函数体内可用。请注意，displayName() 没有自己的局部变量。然而，因为它可以访问到外部函数的变量，所以 displayName() 可以使用父函数 init() 中声明的变量 name 。\n从例子上可以看出，其实就是一种作用域链，在displayName内部函数中，访问name属性，但在其内部作用域中没有找到name属性，因此往作用域链上找，也就是在init函数里面找到了name属性。\n有意义的闭包根据上面例子改造：\nfunction init() &#123;\n  var name &#x3D; &quot;Mozilla&quot;\n  return function displayName() &#123;\n    console.log(name)\n  &#125;\n&#125;\nlet fn &#x3D; init()\nfn()\n\n此案例中，在init函数中，返回displayName函数，且在displayName函数内引用了外部函数init的中变量name，此时就形成了一个闭包。\n使用场景柯里化函数柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用。\n&#x2F;&#x2F; 假设我们有一个求长方形面积的函数\nfunction getArea(width, height) &#123;\n    return width * height\n&#125;\n&#x2F;&#x2F; 柯里化之前\n&#x2F;&#x2F; 如果我们碰到的长方形的宽老是10\nconst area1 &#x3D; getArea(10, 20)\nconst area2 &#x3D; getArea(10, 30)\nconst area3 &#x3D; getArea(10, 40)\n\n&#x2F;&#x2F; 我们可以使用闭包柯里化这个计算面积的函数\nfunction getArea(width) &#123;\n    return height &#x3D;&gt; &#123;\n        return width * height\n    &#125;\n&#125;\n\nconst getTenWidthArea &#x3D; getArea(10)\n&#x2F;&#x2F; 之后碰到宽度为10的长方形就可以这样计算面积\nconst area1 &#x3D; getTenWidthArea(20)\n\n&#x2F;&#x2F; 而且如果遇到宽度偶尔变化也可以轻松复用\nconst getTwentyWidthArea &#x3D; getArea(20)\n\n\n闭包总结\n  形成：  函数中嵌套函数，且内部函数引用外部函数的变量\n  作用：  延长变量生命周期\n  优点：  希望一个变量长期存在内存中、模块化代码避免全局变量的污染、私有属性\n  缺点：  无法回收闭包中引用变量，容易造成内存泄漏\n\n","slug":"javascript/bibao","date":"2021-09-26T12:30:40.078Z","categories_index":"web","tags_index":"JavaScript","author_index":"黄振威"},{"id":"0bf9a689624da39bf1a0f3472d46351e","title":"ES6新特性总结","content":"ES6新特性总结ps: 借鉴阮一峰老师的ECMAScript 6 入门；传送门，MDN文档；传送门\nlet、const、var关键字三个关键字的比较：\n\n\n\nvar\nlet\nConst\n\n\n\n变量提升\n√\n×\n×\n\n\n全局变量\n√\n×\n×\n\n\n重复声明\n√\n×\n×\n\n\n重新赋值\n√\n√\n×\n\n\n只声明不初始化\n√\n√\n×\n\n\n暂时死区\n×\n√\n√\n\n\n块作用域\n×\n√\n√\n\n\n什么是暂时性死区？let 和 const 声明的变量不存在变量提升，其作用域都是块级作用域，凡是在声明变量之前使用变量就会报错，所以，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）\nconst关键字你不知道的事：1、对象属性修改和数组元素变化不会触发 const 错误\n原因： const 实际上是将 const 变量存储的那个指针固定，因此如果声明的是引用数据类型，只是不能修改指针，但是可以修改指针指向的内存数据\n2、声明对象类型优先使用  const ，非对象类型声明优先选择 let\n变量的解构赋值数组的解构ES5中，为了从数组中获取特定数据并赋值给变量，我们经常会进行如下的操作：\nconst arr &#x3D; [100, 200, 300]\nconst a &#x3D; arr[0]\nconst b &#x3D; arr[1]\nconst c &#x3D; arr[2]\nconsole.log(a) &#x2F;&#x2F; 100\nconsole.log(b) &#x2F;&#x2F; 200\nconsole.log(c) &#x2F;&#x2F; 300\n\nES6为数组添加了解构功能，以简化获取数组中数据的过程。数组解构采用数组字面量的语法形式，即等号左边的变量通过在数组中的位置去取得等号右边的数组字面量相同位置的值。\n例子：\nconst arr &#x3D; [100, 200, 300]\nconst [a, b, c] &#x3D; arr\nconsole.log(a) &#x2F;&#x2F; 100\nconsole.log(b) &#x2F;&#x2F; 200\nconsole.log(c) &#x2F;&#x2F; 300\n\n如果只需要拿到数组指定位置的元素\n例子：\nconst arr &#x3D; [100, 200, 300]\nconst [a] &#x3D; arr\nconsole.log(a) &#x2F;&#x2F; 100\nconst [, b] &#x3D; arr\nconsole.log(b) &#x2F;&#x2F; 200\nconst [, , c] &#x3D; arr\nconsole.log(c) &#x2F;&#x2F; 300\n\n\n\n其中，我们还可以使用扩展运算符的方式（…）结构出从当前位置到最后位置从而合并成一个新数组\n例子：\nconst arr &#x3D; [100, 200, 300]\nconst [a, ...arr1] &#x3D; arr\nconsole.log(a) &#x2F;&#x2F; 100\nconsole.log(arr1) &#x2F;&#x2F; [200, 300]\n\n\n\n当解构左边比实际数组的长度还多的时候，多余的变量默认值为undefind\n例子：\nconst arr &#x3D; [100, 200, 300]\nconst [a, b, c, d] &#x3D; arr\nconsole.log(d) &#x2F;&#x2F; undefind\n&#x2F;&#x2F; 我们可以给d设置默认值\nconst [a, b, c, d &#x3D; 400] &#x3D; arr\nconsole.log(d) &#x2F;&#x2F; 400\n\n\n\n对象的解构对象的解构和数组解构不同的是，数组解构是根据数组的下标顺序，解构出相对应下标的元素，\n而对象是没有下标这种规律性的，需要根据对象中的属性名解构。\n其他特点和数组的解构都是相同的。\n例子：\nconst obj &#x3D; &#123; name: &#39;weision&#39;, age: 18 &#125;\nconst &#123; name &#125; &#x3D; obj\nconsole.log(name) &#x2F;&#x2F; weision\n\n&#x2F;&#x2F; 利用这个特性，可以结构出console中的log方法，帮助我们在开发中写少量的代码\nconst &#123; log &#125; &#x3D; console\nlog(name) &#x2F;&#x2F; weision\n\n\n\n模版字符串传统的  JavaScript  语言，输出模板通常是这样写的（下面使用了  jQuery  的方法）。\n$(&#39;#result&#39;).append(\n  &#39;There are &lt;b&gt;&#39; + basket.count + &#39;&lt;&#x2F;b&gt; &#39; +\n  &#39;items in your basket, &#39; +\n  &#39;&lt;em&gt;&#39; + basket.onSale +\n  &#39;&lt;&#x2F;em&gt; are on sale!&#39;\n);\n\n上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。\n$(&#39;#result&#39;).append(&#96;\n  There are &lt;b&gt;$&#123;basket.count&#125;&lt;&#x2F;b&gt; items\n   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;&#x2F;em&gt;\n  are on sale!\n&#96;);\n\n模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\n&#x2F;&#x2F; 普通字符串\n&#96;In JavaScript &#39;\\n&#39; is a line-feed.&#96;\n\n&#x2F;&#x2F; 多行字符串\n&#96;In JavaScript this is\n not legal.&#96;\n\nconsole.log(&#96;string text line 1\nstring text line 2&#96;);\n\n&#x2F;&#x2F; 字符串中嵌入变量\nlet name &#x3D; &quot;Bob&quot;, time &#x3D; &quot;today&quot;;\n&#96;Hello $&#123;name&#125;, how are you $&#123;time&#125;?&#96;\n\n\n\n字符串的扩展方法这里介绍三个比较常用的查找字符串的方法\nincludes()，startaWith()，endsWith()\n分别为\n\n是否包含某个字符串\n是否以某个字符串开头\n是否以某个字符串结尾\n\n他们返回的都是 Boolean 类型\n例子：\nconst message &#x3D; &#39;Error: foo is not defind.&#39;\n\nconsole.log(message.includes(‘foo’)) &#x2F;&#x2F; true \nconsole.log(message.startaWith(‘Error’)) &#x2F;&#x2F; true \nconsole.log(message.endsWith(‘.’)) &#x2F;&#x2F; true \n\n箭头函数在 MDN 上的定义：箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。\n&#x2F;&#x2F; 普通函数\nfunction inc (number) &#123;\n\treturn number + 1\n&#125;\nconsole.log(inc(1)) &#x2F;&#x2F; 2\n\n&#x2F;&#x2F; 箭头函数\nconst inc &#x3D; (n) &#x3D;&gt; &#123;\n    return n + 1\n&#125;\nconsole.log(inc(1)) &#x2F;&#x2F; 2\n\n&#x2F;&#x2F; 最简方式\nconst inc &#x3D; n &#x3D;&gt; n + 1\nconsole.log(inc(1)) &#x2F;&#x2F; 2\n\n箭头函数不会改变 this 指向\n例子：\n&#x2F;&#x2F; 普通函数\nconst person &#x3D; &#123;\n  name: &#39;weision&#39;,\n  sayHi: function () &#123;\n    console.log(&#96;hi, my name is $&#123;this.name&#125;&#96;)\n  &#125;\n&#125;\nperson.sayHi() &#x2F;&#x2F; hi, my name is weision\n\n&#x2F;&#x2F; 箭头函数\nconst person &#x3D; &#123;\n  name: &#39;weision&#39;,\n  sayHi: () &#x3D;&gt; &#123;\n    console.log(&#96;hi, my name is $&#123;this.name&#125;&#96;)\n  &#125;\n&#125;\nperson.sayHi() &#x2F;&#x2F; hi, my name is undefined\n\n\n对象的新增方法1. Object.assign()基础用法\nObject.assign()方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。\nconst target &#x3D; &#123; a: 1 &#125;;\n\nconst source1 &#x3D; &#123; b: 2 &#125;;\nconst source2 &#x3D; &#123; c: 3 &#125;;\n\nObject.assign(target, source1, source2);\ntarget &#x2F;&#x2F; &#123;a:1, b:2, c:3&#125;\n\n注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\nconst target &#x3D; &#123; a: 1, b: 1 &#125;;\n\nconst source1 &#x3D; &#123; b: 2, c: 2 &#125;;\nconst source2 &#x3D; &#123; c: 3 &#125;;\n\nObject.assign(target, source1, source2);\ntarget &#x2F;&#x2F; &#123;a:1, b:2, c:3&#125;\n\n如果只有一个参数，Object.assign()会直接返回该参数。\nconst obj &#x3D; &#123;a: 1&#125;;\nObject.assign(obj) &#x3D;&#x3D;&#x3D; obj &#x2F;&#x2F; true\n\n如果该参数不是对象，则会先转成对象，然后返回。\ntypeof Object.assign(2) &#x2F;&#x2F; &quot;object&quot;\n\n注意点\n1.浅拷贝\nObject.assign()方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。\nconst obj1 &#x3D; &#123;a: &#123;b: 1&#125;&#125;;\nconst obj2 &#x3D; Object.assign(&#123;&#125;, obj1);\n\nobj1.a.b &#x3D; 2;\nobj2.a.b &#x2F;&#x2F; 2\n\n上面代码中，源对象obj1的a属性的值是一个对象，Object.assign()拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。\n2.数组的处理\nObject.assign()可以用来处理数组，但是会把数组视为对象。\nObject.assign([1, 2, 3], [4, 5]) &#x2F;&#x2F; [4, 5, 3]\n\n上面代码中，Object.assign()把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。\n2.Object.is()ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\nES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\nObject.is(&#39;foo&#39;, &#39;foo&#39;) &#x2F;&#x2F; true\n\nObject.is(&#123;&#125;, &#123;&#125;) &#x2F;&#x2F; false\n\n不同之处只有两个：一是+0不等于-0，二是NaN等于自身。\n+0 &#x3D;&#x3D;&#x3D; -0 &#x2F;&#x2F;true\nNaN &#x3D;&#x3D;&#x3D; NaN &#x2F;&#x2F; false\n\nObject.is(+0, -0) &#x2F;&#x2F; false\nObject.is(NaN, NaN) &#x2F;&#x2F; true\n\n\n\nProxyProxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。\n语法const p &#x3D; new Proxy(target, handler)\n\n参数target\n要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。\nhandler\n一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。\nhandler两个重要的对象的方法\n\nhandler.get() 用于拦截对象的读取属性操作。\nvar p &#x3D; new Proxy(target, &#123;\n  get: function(target, property, receiver) &#123;\n  &#125;\n&#125;);\nhandler.set() 用于设置属性值操作的捕获器。\nconst p &#x3D; new Proxy(target, &#123;\n  set: function(target, property, value, receiver) &#123;\n  &#125;\n&#125;);\n\n参数解读\ntarget： 目标对象。\nproperty： 将被设置的属性名或 Symbol。\nvalue： 新属性值。\nreceiver： 最初被调用的对象。通常是 proxy 本身，但 handler 的 set 方法也有可能在原型链上，或以其他方式被间接地调用（因此不一定是 proxy 本身）。\n比如：\n假设有一段代码执行 &#96;obj.name &#x3D; &quot;jen&quot;&#96;， &#96;obj&#96; 不是一个 proxy，且自身不含 &#96;name&#96; 属性，但是它的原型链上有一个 proxy，那么，那个 proxy 的 &#96;set()&#96; 处理器会被调用，而此时，&#96;obj&#96; 会作为 receiver 参数传进来。\n\n​    \nProxy 对比 Object.defineProperty()优势1：Proxy 可以监视读写以外的操作\nconst person &#x3D; &#123;\n  name: &#39;weision&#39;,\n  age: 18\n&#125;\n\nconst personProxy &#x3D; new Proxy(person, &#123;\n  deleteProperty (target, property) &#123;\n    console.log(&#39;delete&#39;, property)\n    delete target[property] \n  &#125;\n&#125;)\n\ndelete personProxy.age\nconsole.log(person)\n\n优势2：Proxy 可以很方便的监视数组操作\nconst list &#x3D; []\n\nconst listProxy &#x3D; new Proxy(list, &#123;\n  set (target, property, value) &#123;\n    console.log(&#39;set&#39;, property, value)\n    target[property] &#x3D; value\n    return true &#x2F;&#x2F; 表示设置成功\n  &#125;\n&#125;)\n\nlistProxy.push(100)\nlistProxy.push(100)\n\n优势3：Proxy 不需要侵入对象\nconst person &#x3D; &#123;&#125;\n\nObject.defineProperty(person, &#39;name&#39;, &#123;\n  get () &#123;\n    console.log(&#39;name 被访问&#39;)\n    return person._name\n  &#125;,\n  set (value) &#123;\n    console.log(&#39;name 被设置&#39;)\n    person._name &#x3D; value\n  &#125;\n&#125;)\nObject.defineProperty(person, &#39;age&#39;, &#123;\n  get () &#123;\n    console.log(&#39;age 被访问&#39;)\n    return person._age\n  &#125;,\n  set (value) &#123;\n    console.log(&#39;age 被设置&#39;)\n    person._age &#x3D; value\n  &#125;\n&#125;)\n\nperson.name &#x3D; &#39;jack&#39;\n\nconsole.log(person.name)\n\n&#x2F;&#x2F; Proxy 方式更为合理\nconst person2 &#x3D; &#123;\n  name: &#39;zce&#39;,\n  age: 20\n&#125;\n\nconst personProxy &#x3D; new Proxy(person2, &#123;\n  get (target, property) &#123;\n    console.log(&#39;get&#39;, property)\n    return target[property]\n  &#125;,\n  set (target, property, value) &#123;\n    console.log(&#39;set&#39;, property, value)\n    target[property] &#x3D; value\n  &#125;\n&#125;)\n\npersonProxy.name &#x3D; &#39;jack&#39;\n\nconsole.log(personProxy.name)\nconsole.log(personProxy.name)\n\n\n\nPromiseps: 借鉴MDN上promise概念描述，加上自己的语境和案例记录学习promise的成果，MDN传送门。\n描述一个 Promise 对象代表一个在这个 promise 被创建出来时不一定已知的值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 promise，以便在未来某个时候把值交给使用者。\n一个 Promise 必然处于以下几种状态之一：\n\n待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。\n已兑现（fulfilled）: 意味着操作成功完成。\n已拒绝（rejected）: 意味着操作失败。\n\n待定状态的 Promise 对象要么会通过一个值被兑现（fulfilled），要么会通过一个原因（错误）被拒绝（rejected）。当这些情况之一发生时，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。如果 promise 在一个相应的处理程序被绑定时就已经被兑现或被拒绝了，那么这个处理程序就会被调用，因此在完成异步操作和绑定处理方法之间不会存在竞争状态。\n解决什么问题promise主要是用来解决以下问题的：\n\n回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象\npromise可以支持多个并发的请求，获取并发请求中的数据\n\n\u000b\n&#x2F;&#x2F; 回调地狱，只是示例，不能运行\n\n$.get(&#39;&#x2F;url1&#39;, function (data1) &#123;\n  $.get(&#39;&#x2F;url2&#39;, data1, function (data2) &#123;\n    $.get(&#39;&#x2F;url3&#39;, data2, function (data3) &#123;\n      $.get(&#39;&#x2F;url4&#39;, data3, function (data4) &#123;\n        $.get(&#39;&#x2F;url5&#39;, data4, function (data5) &#123;\n          $.get(&#39;&#x2F;url6&#39;, data5, function (data6) &#123;\n            $.get(&#39;&#x2F;url7&#39;, data6, function (data7) &#123;\n              &#x2F;&#x2F; 略微夸张了一点点\n            &#125;)\n          &#125;)\n        &#125;)\n      &#125;)\n    &#125;)\n  &#125;)\n&#125;)\n\n以上回调地狱代码示例，在远古时期（promise诞生前）经常遇到，这让开发者很难维护和读解代码。\nPromise 基本示例const promise &#x3D; new Promise(function (resolve, reject) &#123;\n  &#x2F;&#x2F; 这里用于“兑现”承诺\n\n  &#x2F;&#x2F; resolve(100) &#x2F;&#x2F; 承诺达成\n\n  reject(new Error(&#39;promise rejected&#39;)) &#x2F;&#x2F; 承诺失败\n&#125;)\n\npromise.then(function (value) &#123;\n  &#x2F;&#x2F; 即便没有异步操作，then 方法中传入的回调仍然会被放入队列，等待下一轮执行\n  console.log(&#39;resolved&#39;, value)\n&#125;, function (error) &#123;\n  console.log(&#39;rejected&#39;, error)\n&#125;)\n\nconsole.log(&#39;end&#39;)\n\nPromise 方式的 AJAXfunction ajax (url) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    var xhr &#x3D; new XMLHttpRequest()\n    xhr.open(&#39;GET&#39;, url)\n    xhr.responseType &#x3D; &#39;json&#39;\n    xhr.onload &#x3D; function () &#123;\n      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        resolve(this.response)\n      &#125; else &#123;\n        reject(new Error(this.statusText))\n      &#125;\n    &#125;\n    xhr.send()\n  &#125;)\n&#125;\n\najax(&#39;&#x2F;api&#x2F;foo.json&#39;).then(function (res) &#123;\n  console.log(res)\n&#125;, function (error) &#123;\n  console.log(error)\n&#125;)\n\n\n\n\nPromise 常见误区function ajax (url) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    var xhr &#x3D; new XMLHttpRequest()\n    xhr.open(&#39;GET&#39;, url)\n    xhr.responseType &#x3D; &#39;json&#39;\n    xhr.onload &#x3D; function () &#123;\n      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        resolve(this.response)\n      &#125; else &#123;\n        reject(new Error(this.statusText))\n      &#125;\n    &#125;\n    xhr.send()\n  &#125;)\n&#125;\n\n&#x2F;&#x2F; 嵌套使用 Promise 是最常见的误区\n&#x2F;&#x2F; ajax(&#39;&#x2F;api&#x2F;urls.json&#39;).then(function (urls) &#123;\n&#x2F;&#x2F;   ajax(urls.users).then(function (users) &#123;\n&#x2F;&#x2F;     ajax(urls.users).then(function (users) &#123;\n&#x2F;&#x2F;       ajax(urls.users).then(function (users) &#123;\n&#x2F;&#x2F;         ajax(urls.users).then(function (users) &#123;\n\n&#x2F;&#x2F;         &#125;)\n&#x2F;&#x2F;       &#125;)\n&#x2F;&#x2F;     &#125;)\n&#x2F;&#x2F;   &#125;)\n&#x2F;&#x2F; &#125;)\n\n\n\nPromise 链式调用我们可以用 promise.then()，promise.catch() 和 promise.finally() 这些方法将进一步的操作与一个变为已敲定状态的 promise 关联起来。这些方法还会返回一个新生成的 promise 对象，这个对象可以被非强制性的用来做链式调用，就像这样：\n以下所有示例中的ajax方法都在上面Promise常见误区中。\n\najax(&#39;&#x2F;api&#x2F;users.json&#39;)\n  .then(function (value) &#123;\n    console.log(1111)\n    return ajax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  &#125;) &#x2F;&#x2F; &#x3D;&gt; Promise\n  .then(function (value) &#123;\n    console.log(2222)\n    console.log(value)\n    return ajax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  &#125;) &#x2F;&#x2F; &#x3D;&gt; Promise\n  .then(function (value) &#123;\n    console.log(3333)\n    return ajax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  &#125;) &#x2F;&#x2F; &#x3D;&gt; Promise\n  .then(function (value) &#123;\n    console.log(4444)\n    return &#39;foo&#39;\n  &#125;) &#x2F;&#x2F; &#x3D;&gt; Promise\n\t.catch(function (value) &#123;\n    console.log(&#39;error&#39;, value)\n  &#125;)\n\n\n\nPromise  静态方法\nPromise.resolve(value)\n\n返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果您不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。\n\nPromise.resolve(&#39;foo&#39;)\n  .then(function (value) &#123;\n    console.log(value) &#x2F;&#x2F; foo\n  &#125;)\nPromise.reject(reason)\n\n返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法\n\n&#x2F;&#x2F; Promise.reject 传入任何值，都会作为这个 Promise 失败的理由\n\nPromise.reject(&#39;anything&#39;)\n  .catch(function (error) &#123;\n    console.log(error)\n  &#125;)\n\nPromise.reject(new Error(&#39;rejected&#39;))\n  .catch(function (error) &#123;\n    console.log(error)\n  &#125;)\nPromise.all(iterable)\n\n这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。\n\n&#x2F;&#x2F; 需要等待所有promise结束才会返回对应结果。\n&#x2F;&#x2F; 只有所有的promise都成功才能走.then()\n&#x2F;&#x2F; 否则走catch\nvar promise &#x3D; Promise.all([\n  ajax(&#39;&#x2F;api&#x2F;users.json&#39;),\n  ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)\n])\n\npromise.then(function (values) &#123;\n  console.log(values)\n&#125;).catch(function (error) &#123;\n  console.log(error\n&#125;\nPromise.any(iterable)\n\n接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。\n\n&#x2F;&#x2F; 只要有一个promise成功，立刻返回该成功的promise的值。\n&#x2F;&#x2F; 否则走catch\n\nvar promise &#x3D; Promise.all([\n  ajax(&#39;&#x2F;api&#x2F;users.json&#39;),\n  ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)\n])\n\npromise.then(function (values) &#123;\n  console.log(values)\n&#125;).catch(function (error) &#123;\n  console.log(error)\n&#125;\nPromise.race(iterable)\n\n当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。\n\n&#x2F;&#x2F; 实现超时控制\n&#x2F;&#x2F; 如果 reauest 请求未得到响应，500毫秒内就触发定时器，返回reject\nconst request &#x3D; ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)\nconst timeout &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; reject(new Error(&#39;timeout&#39;)), 500)\n&#125;)\n\nPromise.race([\n  request,\n  timeout\n])\n.then(value &#x3D;&gt; &#123;\n  console.log(value)\n&#125;)\n.catch(error &#x3D;&gt; &#123;\n  console.log(error)\n&#125;)\n\n\nclass 类","slug":"es/es6","date":"2021-09-26T12:30:40.064Z","categories_index":"web","tags_index":"ES6","author_index":"黄振威"}]